<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue-router | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/47.7987c6b9.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/18.bc0ab2ef.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/24.bcb02ed7.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/41.6f245bcc.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/43.2e2eee59.js"><link rel="prefetch" href="/Blog/assets/js/44.36c49c87.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/Vue/" aria-current="page" class="sidebar-link">基础概念</a></li><li><a href="/Blog/Vue/AllLife.html" class="sidebar-link">生命周期</a></li><li><a href="/Blog/Vue/Router.html" aria-current="page" class="active sidebar-link">路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#vue-router" class="sidebar-link">Vue-router</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#动态路由匹配" class="sidebar-link">动态路由匹配</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#响应路由参数变化" class="sidebar-link">响应路由参数变化</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#捕获所有路由和404-not-foundluyu路由。" class="sidebar-link">捕获所有路由和404 Not Foundluyu路由。</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#嵌套路由" class="sidebar-link">嵌套路由</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#命名路由" class="sidebar-link">命名路由</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#重定向和别名" class="sidebar-link">重定向和别名</a></li><li class="sidebar-sub-header"><a href="/Blog/Vue/Router.html#路由组件传参" class="sidebar-link">路由组件传参</a></li></ul></li><li><a href="/Blog/Vue/Vue3.html" class="sidebar-link">Vue3</a></li><li><a href="/Blog/Vue/vueX.html" class="sidebar-link">vueX</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> Vue-router</h2> <p><code>https://juejin.im/post/6844903874533261325#heading-0</code></p> <h3 id="router和route-https-www-cnblogs-com-shaozhu520-p-11298805-html"><a href="#router和route-https-www-cnblogs-com-shaozhu520-p-11298805-html" class="header-anchor">#</a> router和route  https://www.cnblogs.com/shaozhu520/p/11298805.html</h3> <h3 id="一-编程式导航"><a href="#一-编程式导航" class="header-anchor">#</a> 一 编程式导航</h3> <blockquote><p><code>&lt;router-link :to=&quot;&quot;&gt;</code>创建a标签来定义导航，还可借助router的实例方法。</p></blockquote> <table><thead><tr><th>声明式</th> <th>编码式</th></tr></thead> <tbody><tr><td><code>&lt;router-link :to=&quot;..&quot;</code></td> <td><code>router.push(...)</code></td></tr></tbody></table> <blockquote><p>使用router.push的方法，这个方法<strong>会向history栈中添加一个新的记录，当用户点击后退时，则回到之前的url</strong></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如:
// 字符串
router.push('home')

// 对象
router.push({path: 'home'})

// 命名的路由
router.push({name: 'user', params: {userid: 123}})

// 带参数查询，变成/register?plan=private
router.push({path: 'user', query: { plan:'private'}})
接受
const a = this.$route.query.plan

</code></pre></div><blockquote><p>提供的params，path会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const userId = '123'
router.push({name: 'user', params: {userId}})  // -&gt;  /user/123
router.push({path: `/user/${userId}`}) // -&gt; /user/123

// params不生效  ×
router.push({path: `/user`, params: {userId}})
</code></pre></div><blockquote><p>同样也适用于router-link组件的to属性</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link :to=&quot;{name: 'user', params: {userId: 123}}&quot;&gt;User&lt;/router-link&gt;
或者
router.push({name: 'user', params: {userId: 123})
</code></pre></div><h3 id="二-router-replace-location-oncomplete-onabort"><a href="#二-router-replace-location-oncomplete-onabort" class="header-anchor">#</a> 二 router.replace(location, onComplete?, onAbort?)</h3> <ol><li>和router.push像，不同的是不会向history添加新纪录，而和它的方法名一样——替换掉当前history记录。</li> <li>router.go(n)，参数为整数，意思在history记录中向前或者后退多少步。类似window.history.go(n)。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)

// 后退一步记录，等同于 history.back()
router.go(-1)

// 前进 3 步记录
router.go(3)

// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)

</code></pre></div><h2 id="动态路由匹配"><a href="#动态路由匹配" class="header-anchor">#</a> 动态路由匹配</h2> <div class="language- extra-class"><pre class="language-text"><code>const User = {
    template: '&lt;div&gt;User&lt;/div&gt;'
}

const router = new VueRouter({
    routers: [
        // 动态路径参数 以冒号开头
        {path: '/user/:id', conponent: User}
    ]
})
</code></pre></div><blockquote><p>/suer/foo和/user/bar都将映射到相同的路由，并用同一个模板渲染。可以利用<strong>this.$route.params.id</strong>获取值。此处id是冒号后面的值，只要跟params后面的属性一样就能取到。</p></blockquote> <ol><li>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 $route.params 中。例如：</li></ol> <table><thead><tr><th>模式</th> <th>匹配路径</th> <th>this.$route.params</th></tr></thead> <tbody><tr><td>/user/:username</td> <td>/user/evan</td> <td>{username: 'evan'}</td></tr> <tr><td>/user/:username/post/:post_id</td> <td>/user/evan/post/123</td> <td>{username: 'evan', post_id: '123'}</td></tr></tbody></table> <blockquote><p>除了route.params外，route对象还提供了：route.query(如果url中有查询参数)，route.hash。</p></blockquote> <h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="header-anchor">#</a> 响应路由参数变化</h2> <p><strong>使用路由参数时，从/user/foo导航到/user/bar,原来的组件实例会被复用，<strong>两个路由都使用同个组件，比起销毁，复用则显得更加高效。不过也意味着</strong>组件生命周期钩子不会被点用</strong></p> <ol><li>复用组件时，相对路由参数做出响应的话，可以简单的watch（监测变化）$route对象：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const user = {
    template: '...',
    watch: {
        '$route'(to, from){
            // 对路由做出响应
        }
    }
}
</code></pre></div><ol start="2"><li>使用2.2中的beforeRouteUpdate导航守卫：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const User = {
    template: '...',
    beforeRouteUpdate(to, from, next){
        // react to route changes
        // do not forget to call next()
    }
}
</code></pre></div><h2 id="捕获所有路由和404-not-foundluyu路由。"><a href="#捕获所有路由和404-not-foundluyu路由。" class="header-anchor">#</a> 捕获所有路由和404 Not Foundluyu路由。</h2> <ol><li>常规参数只会被/分割的url片段中的字符。如果想匹配任意路径，可以使用通佩符(*)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>{
    // 会匹配所有路径
    path: '*'
}
{
    // 匹配所有以`/user-`开头的路径
    path: '/user-*'
}
</code></pre></div><blockquote><p>当使用通配符路由时，请确保路由的顺序是正确的，<em>含通配符的路由应该放到最后面。路由{path: '</em>'}常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。</p></blockquote> <ol start="2"><li>当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch参数。它包含了URL通过通配符被匹配的部分：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 给出一个路由：{path: '/user-*'}
this.$router.push('/user-admin')
this.$route.params.pathMatch   // 'admin'

// 给出一个理由
this.$router.push('/non-existing')
this.$route.params.pathMatch // '/non-existing'
</code></pre></div><h2 id="嵌套路由"><a href="#嵌套路由" class="header-anchor">#</a> 嵌套路由</h2> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
    routers: [
        {path: '/user/:id', component: User,
            children: [
                {
                    //   当/user/:id/profile匹配成功，
                    //   UserProfile 会被渲染在User的&lt;router-view&gt;中

                    path: 'profile',
                    component: UserProfile
                },
                {
                    //   当/user/:id/posts匹配成功，
                    //   UserPosts会被渲染在User的&lt;router-view&gt;中

                    path: 'posts',
                    component: UserPosts
                }
            ]
        }
    ]
})
</code></pre></div><p>基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个空的子路由：</p> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    {
      path: '/user/:id', component: User,
      children: [
            //    当 /user/:id 匹配成功，
            //    UserHome 会被渲染在 User 的 &lt;router-view&gt; 中
            {   
                path: '', 
                component: UserHome
            },

            // ...其他子路由
       ]
    }
  ]
})
</code></pre></div><h2 id="命名路由"><a href="#命名路由" class="header-anchor">#</a> 命名路由</h2> <ol><li>通过命名标识一个路由，创建Router实例的时候，在routes配置中设置名称。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
    routes: [
        {
            path: '/user/:userId',
            name: 'user',
            compoent: User
        }
    ]
})
</code></pre></div><ol start="2"><li>要链接到一个命名路由，可以给router-link的to属性传一个对象：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link :to=&quot;{name: 'user', params: &quot;{userId: 123}&quot;}&quot;&gt;user&lt;/router-link&gt;
</code></pre></div><ol start="3"><li>和调用router.push()情况差不多</li></ol> <div class="language- extra-class"><pre class="language-text"><code>router.push({name: 'suer', params: { userId: 123 }})
</code></pre></div><p>两种方式都可以导向/user/123路径</p> <h2 id="重定向和别名"><a href="#重定向和别名" class="header-anchor">#</a> 重定向和别名</h2> <ol><li>重定向通过routes配置，下面从/a重定向到/b</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
    routes: [
        {
            path: '/a',
            redirect: '/b'
        }
    ]
})
</code></pre></div><ol start="2"><li>重定向的目标也可以是个命名路由</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    { path: '/a', redirect: { name: 'foo' }}
  ]
})
</code></pre></div><ol start="3"><li>甚至是一个方法，动态返回重定向目标：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    { path: '/a', redirect: to =&gt; {
      // 方法接收 目标路由 作为参数
      // return 重定向的 字符串路径/路径对象
    }}
  ]
})
</code></pre></div><blockquote><p>注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。</p></blockquote> <ol start="4"><li>别名
/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    { path: '/a', component: A, alias: '/b' }
  ]
})
</code></pre></div><h2 id="路由组件传参"><a href="#路由组件传参" class="header-anchor">#</a> 路由组件传参</h2> <p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 props 将组件和路由解耦</p> <div class="language- extra-class"><pre class="language-text"><code>const User = {
   props: [id],
   template: '&lt;div&gt;UserId: {{id}}&lt;/div&gt;'
}

const router = new VueRouter({
    routes: [
        {
            path: '/user/:id',
            component: User,
            props: true
        },
        // 对于包含命名视图的路由，必须为每个命名视图添加props选项
        {
            path: '/user/:id',
            components: { default: User, sidebar: Sidebar },
            props: { default: true, sidebar: false }
        }
    ]
})
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Blog/Vue/AllLife.html" class="prev">
        生命周期
      </a></span> <span class="next"><a href="/Blog/Vue/Vue3.html">
        Vue3
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/47.7987c6b9.js" defer></script>
  </body>
</html>
