<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. Hook | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/24.bcb02ed7.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/18.bc0ab2ef.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/41.6f245bcc.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/43.2e2eee59.js"><link rel="prefetch" href="/Blog/assets/js/44.36c49c87.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/47.7987c6b9.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link router-link-active">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link router-link-active">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/Difficulties/" aria-current="page" class="sidebar-link">JS注意点-难点</a></li><li><a href="/Blog/Difficulties/Vue.html" class="sidebar-link">Vue注意点-难点</a></li><li><a href="/Blog/Difficulties/React.html" aria-current="page" class="active sidebar-link">React注意点-难点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_1-hook" class="sidebar-link">1. Hook</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_2-react复用状态逻辑的解决方案" class="sidebar-link">2. React复用状态逻辑的解决方案</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_3-antd-design-for-react" class="sidebar-link">3. Antd design for React</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_4-react-render执行流程" class="sidebar-link">4. react render执行流程</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_5-react-diffing算法" class="sidebar-link">5. React-diffing算法</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_6-父组件点击子组件执行" class="sidebar-link">6. 父组件点击子组件执行</a></li><li class="sidebar-sub-header"><a href="/Blog/Difficulties/React.html#_7-component和pureconponent区别" class="sidebar-link">7 Component和PureConponent区别</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-hook"><a href="#_1-hook" class="header-anchor">#</a> 1. Hook</h2> <ul><li><p>React Hooks要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享</p></li> <li><p>React Hook</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { useState } from 'React';

function Example() {
  // Declare a new state variable, which we'll call &quot;count&quot;
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

</code></pre></div><ul><li>React State</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre></div><p><strong>在React Hook中，class Example组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都得益于useState这个Hook，useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并</strong></p> <h2 id="_2-react复用状态逻辑的解决方案"><a href="#_2-react复用状态逻辑的解决方案" class="header-anchor">#</a> 2. React复用状态逻辑的解决方案</h2> <ul><li>Mixin -&gt; 高阶组件 -&gt; Render Props -&gt; Hook</li></ul> <h4 id="mixin到高阶组件"><a href="#mixin到高阶组件" class="header-anchor">#</a> Mixin到高阶组件</h4> <ul><li>Mixin继承看作是通过扩展收集功能的一种途径。.我们定义的每一个新的对象都有一个原型，从中它可以继承更多的属性，原型可以从其他对象继承而来，但是更重要的是，能够为任意数量的对象定义属性，我们可以利用这一事实来促进功能重用。
<blockquote><p>缺点
不同mixin可能会相互依赖，耦合性太强，导致后期维护成本过高<br>
mixin中的命名可能会冲突，无法使用同一命名的mixin<br>
mixin即使开始很简单，它们会随着业务场景增多，时间的推移产生滚雪球式的复杂化</p></blockquote></li></ul> <h4 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h4> <ul><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li> <li>高阶组件可以看做是装饰者模式(Decorator Pattern)在React的实现。装饰者模式: 动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。</li></ul> <h4 id="装饰者模式"><a href="#装饰者模式" class="header-anchor">#</a> 装饰者模式</h4> <ol><li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</li> <li>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</li></ol> <ul><li><strong>高阶组件动态给其他组件增加日志打印功能</strong></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function logProps(WrappedComponent) {
  return class extends React.Component {
    componentWillReceiveProps(nextProps) {
      console.log('Current props: ', this.props);
      console.log('Next props: ', nextProps);
    }
    render() {
      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  }
}

</code></pre></div><h4 id="render-props"><a href="#render-props" class="header-anchor">#</a> Render Props</h4> <ul><li>React 组件之间使用一个值为函数的 prop 共享代码的简单技术。</li> <li>具有 Render Props 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Cat extends React.Component {
  render() {
    const mouse = this.props.mouse;
    return (
      &lt;img src=&quot;/cat.jpg&quot; style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /&gt;
    );
  }
}
——————————————————————————————————————————————————————
class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY
    });
  }

  render() {
    return (
      &lt;div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}&gt;

        {/*
          Instead of providing a static representation of what &lt;Mouse&gt; renders,
          use the `render` prop to dynamically determine what to render.
        */}
        {this.props.render(this.state)}
      &lt;/div&gt;
    );
  }
}
————————————————————————————————————————————————————
class MouseTracker extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;
        &lt;Mouse render={mouse =&gt; (
          &lt;Cat mouse={mouse} /&gt;
        )}/&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre></div><p>简写如下</p> <div class="language- extra-class"><pre class="language-text"><code>Class  Mouse extends React.component{
   ...
   {this.props.render(this.state)}
   ...
}

......
&lt;Mouse render={mouse =&gt; (
          &lt;Cat mouse={mouse} /&gt;
        )}/&gt;
</code></pre></div><p>在使用Mouse组件的时候，通过一个render属性，传递一个可用组件Cat给父组件Mouse，而在Mouse组件中，可以将本身的state对象传递给Cat组件，Cat组件中的mouse属性的值与Mouse父组件中的state相同。<strong>简单来说就是父组件可以将自己的state传递给子组件，而子组件可以根据父组件的state对象，来进行render</strong></p> <h4 id="react-hook"><a href="#react-hook" class="header-anchor">#</a> React Hook</h4> <ul><li>动机：在组件之间复用状态逻辑很难，复杂组件变得难以理解，难以理解的 class。</li> <li>语法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React, { useState } from 'React';
const [count, setCount] = useState(0);

等价于
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
  };
}
</code></pre></div><ul><li><p>useState参数<br>
传入了0作为useState的参数，这个参数的数值会被当成count初始值。当然此参数<strong>不限于传递数字以及字符串，可以传入一个对象当成初始的state</strong>。如果state需要储存多个变量的值，那么调用多次useState即可</p></li> <li><p>useState返回值<br>
返回值为：当前 state 以及更新 state 的函数，这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。看到[count, setCount]很容易就能明白这是ES6的解构数组的写法。相当于以下代码</p> <div class="language- extra-class"><pre class="language-text"><code>let _useState = useState(0);// 返回一个有两个元素的数组
let count = _useState[0];// 数组里的第一个值
let setCount = _useState[1];// 数组里的第二个值
</code></pre></div></li> <li><p>读取状态值<br>
以前<code>&lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;</code><br>
现在<code>&lt;p&gt;You clicked {count} times&lt;/p&gt;</code></p></li> <li><p>更新状态</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>以前
&lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
    Click me
 &lt;/button&gt;

现在
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;
    Click me
&lt;/button&gt;

</code></pre></div><h5 id="声明多个state变量"><a href="#声明多个state变量" class="header-anchor">#</a> 声明多个state变量</h5> <ul><li>一个组件中多次使用state hook</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function ExampleWithManyStates() {
  // 声明多个 state 变量！
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}
</code></pre></div><p>React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的</p> <h5 id="hook-规则"><a href="#hook-规则" class="header-anchor">#</a> Hook 规则</h5> <ol><li>只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li> <li>只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook。</li></ol> <blockquote><p>这两条规则出现的原因是，我们可以在单个组件中使用多个State Hook 或 Effect Hook，React 靠的是 Hook 调用的顺序来知道哪个 state 对应哪个useStat</p></blockquote> <h5 id="effect-hook使用-effect在组件渲染后执行即可"><a href="#effect-hook使用-effect在组件渲染后执行即可" class="header-anchor">#</a> Effect Hook使用 -&gt; Effect在组件渲染后执行即可</h5> <ul><li>用法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });
</code></pre></div><blockquote><p>如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</p></blockquote> <h5 id="清除副作用"><a href="#清除副作用" class="header-anchor">#</a> 清除副作用</h5> <p>有时候对于一些副作用，我们是需要去清除的，比如我们有个需求需要轮询向服务器请求最新状态，那么我们就需要在卸载的时候，清理掉轮询的操作。</p> <div class="language- extra-class"><pre class="language-text"><code>  常规
  componentDidMount() {
    this.pollingNewStatus()
  }

  componentWillUnmount() {
    this.unPollingNewStatus()
  }

  react hook
  useEffect(() =&gt; {
      pollingNewStatus()
      //告诉React在每次渲染之前都先执行cleanup()
      return function cleanup() {
        unPollingNewStatus()
      };
    });

useEffect其实是每次渲染之前都会去执行cleanup(),而componentWillUnmount只会执行一次
</code></pre></div><h5 id="effect性能优化"><a href="#effect性能优化" class="header-anchor">#</a> Effect性能优化</h5> <ul><li>useEffect其实是每次更新都会执行，在某些情况下会导致性能问题。那么我们可以通过跳过 Effect 进行性能优化。在class组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决</li></ul> <div class="language- extra-class"><pre class="language-text"><code>componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
</code></pre></div><ul><li>在Effect中，我们可以通过增加Effect的第二个参数即可，如果没有变化，则跳过更新</li></ul> <div class="language- extra-class"><pre class="language-text"><code>useEffect(() =&gt; {
  document.title = `You clicked ${count} times`;
}, [count]); // 仅在 count 更改时更新

</code></pre></div><h2 id="_3-antd-design-for-react"><a href="#_3-antd-design-for-react" class="header-anchor">#</a> 3. Antd design for React</h2> <h4 id="input同时"><a href="#input同时" class="header-anchor">#</a> input同时</h4> <h2 id="_4-react-render执行流程"><a href="#_4-react-render执行流程" class="header-anchor">#</a> 4. react render执行流程</h2> <p><code>https://www.jianshu.com/p/021736302706</code></p> <h2 id="_5-react-diffing算法"><a href="#_5-react-diffing算法" class="header-anchor">#</a> 5. React-diffing算法</h2> <p><code>https://juejin.cn/post/6988446977541275661?from=main_page</code></p> <ol><li>虚拟DOM-&gt;真是DOM，会通过diffing算法进行比较，如果已经渲染过一次再进行渲染，会对相同的key值节点进行比较，如果内容相同，会复用原来的真实DOM。</li></ol> <h2 id="_6-父组件点击子组件执行"><a href="#_6-父组件点击子组件执行" class="header-anchor">#</a> 6. 父组件点击子组件执行</h2> <div class="language- extra-class"><pre class="language-text"><code>import React, {Component} from 'react';

export default class Parent extends Component {
    render() {
        return(
            &lt;div&gt;
                &lt;Child onRef={this.onRef} /&gt;
                &lt;button onClick={this.click} &gt;click&lt;/button&gt;
            &lt;/div&gt;
        )
    }

    onRef = (ref) =&gt; {
        this.child = ref
    }

    click = (e) =&gt; {
        this.child.myName()
    }

}

class Child extends Component {
    componentDidMount(){
        this.props.onRef(this)
    }

    myName = () =&gt; alert('xiaohesong')

    render() {
        return ('woqu')
    }
}

</code></pre></div><h2 id="_7-component和pureconponent区别"><a href="#_7-component和pureconponent区别" class="header-anchor">#</a> 7 Component和PureConponent区别</h2> <p><code>https://juejin.cn/post/6943148190174707748</code></p> <div class="language- extra-class"><pre class="language-text"><code>PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，当 prop 或 state 的值或者引用地址发生改变时，组件就会发生更新
Component 只要 state 发生改变， 不论值是否与之前的相等，都会触发更新
</code></pre></div><ol><li>Purecomponent通过props和state浅对比来实现shouldComponentUpdate()</li></ol> <blockquote><p>注意：在 PureComponent 中，当对传入的对象或者数组进行直接赋值时，因为并没有改变其引用地址，所以就不引起重新渲染。
在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新
每当shouldComponentUpdate被调用时，组件默认的会重新渲染。
浅比较：将检查原始值是否有相同的值（例如：1 == 1或者ture==true）,数组和对象引用是否相同。</p></blockquote> <ol start="2"><li>Component不会比较当前和下个状态的props和state。</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Blog/Difficulties/Vue.html" class="prev">
        Vue注意点-难点
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/24.bcb02ed7.js" defer></script>
  </body>
</html>
