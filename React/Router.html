<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端路由规则 | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/44.36c49c87.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/18.bc0ab2ef.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/24.bcb02ed7.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/41.6f245bcc.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/43.2e2eee59.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/47.7987c6b9.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/React/" aria-current="page" class="sidebar-link">基础概念</a></li><li><a href="/Blog/React/LifeCycle.html" class="sidebar-link">生命周期</a></li><li><a href="/Blog/React/Router.html" aria-current="page" class="active sidebar-link">路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/React/Router.html#前端路由规则" class="sidebar-link">前端路由规则</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Router.html#react-router" class="sidebar-link">react-Router</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Router.html#react-router补充" class="sidebar-link">react-router补充</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Router.html#react-router-config" class="sidebar-link">react-router-config</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Router.html#browserrouter-hashrouter" class="sidebar-link">BrowserRouter HashRouter</a></li></ul></li><li><a href="/Blog/React/Redux.html" class="sidebar-link">Redux</a></li><li><a href="/Blog/React/Guidance.html" class="sidebar-link">高级指引</a></li><li><a href="/Blog/React/Hook.html" class="sidebar-link">HooK</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前端路由规则"><a href="#前端路由规则" class="header-anchor">#</a> 前端路由规则</h2> <p><code>https://juejin.im/post/6883729053027844109#heading-5</code></p> <h3 id="一-url中的hash"><a href="#一-url中的hash" class="header-anchor">#</a> 一 Url中的hash</h3> <ol><li>Url的hash也就是锚点（#），本质上是改变window.location的href属性。可以直接复制location.hash改变url，但是<strong>页面不会刷新。</strong></li></ol> <div class="language- extra-class"><pre class="language-text"><code>const routerViewOne = doucument.querySelector('.router-view')
window.addEventListener('hashChange', () =&gt; {
    switch(window.loctiona.hash){
        case '#/home'
            routerViewOne.innerHtml = '首页'
            break;
        case '#/about'
            routerViewOne.innerHtml = '关于'
            break;
        default:
            routerViewOne.innerHtml = ''
            break;
    }
})
</code></pre></div><blockquote><p>hash的优势是兼容性更强，老版IE中也可运行。缺陷<code>#/</code>显得不想真是路径名</p></blockquote> <h3 id="二-html5中的history"><a href="#二-html5中的history" class="header-anchor">#</a> 二 Html5中的history</h3> <ol><li>history接口是Html5新增，有六种模式<strong>改变Url而不刷新页面</strong>方法：</li></ol> <table><thead><tr><th>API</th> <th>作用</th></tr></thead> <tbody><tr><td>replaceState</td> <td>提还原来的路径</td></tr> <tr><td>pushState</td> <td>使用新路径</td></tr> <tr><td>popState</td> <td>路径的回退</td></tr> <tr><td>go</td> <td>向前或向后改变路径</td></tr> <tr><td>forword</td> <td>向前改变路径</td></tr> <tr><td>back</td> <td>向后改变路径</td></tr></tbody></table> <h2 id="react-router"><a href="#react-router" class="header-anchor">#</a> react-Router</h2> <h3 id="一-react-router介绍"><a href="#一-react-router介绍" class="header-anchor">#</a> 一 react-Router介绍</h3> <ol><li>React-Router版本4开始，路由不在集中在一个包管理。react-router是router的核心部分代码，react-router-dom适用于浏览器。react-router-native是用于原生应用。目前是使用的都是V5。安装react-router-dom会自动帮助我们安装react-router依赖。</li></ol> <h3 id="二-router的基本使用-react-router主要api提供的一些组件，"><a href="#二-router的基本使用-react-router主要api提供的一些组件，" class="header-anchor">#</a> 二 Router的基本使用 react-router主要API提供的一些组件，</h3> <ol><li>BrowserRouter或HashRouter组件</li></ol> <ul><li>Router中包含了对路径改变时候的监听，并且会将相应的路径传递给子组件</li> <li>BrowserRouter使用了history模式</li> <li>HashRouter使用了hash模式</li></ul> <ol start="2"><li>Link和NavLink</li></ol> <ul><li>跳转使用Link最后会被渲染成a链接</li> <li>NavLink是在Link基础之上增加了一些样式属性</li> <li>to属性: link组件中最重要的属性, 用于设置跳转到的路径</li></ul> <ol start="3"><li>Route组件用于路径的匹配</li></ol> <ul><li>path(属性)：用户设置匹配到的路径</li> <li>component(属性)：设置到匹配名的后面，渲染组件。</li> <li>exact(属性)：精准匹配，只有精准匹配到完全一样的路径，才会渲染对应的组件。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { BorwserRouter, Link, Route }  from 'react-router-dom'
export default class App extends PureComponent {
    render(){
        return (
            &lt;div&gt;
                &lt;BrowserRouter&gt;
                    &lt;Link to=&quot;/&quot;&gt;主页&lt;/Link&gt;
                    &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;
                    &lt;Link to=&quot;profile&quot;&gt;我的&lt;/Link&gt;     

                    &lt;Route exact path=&quot;/&quot; component = {Home} /&gt;
                    &lt;Route exact path=&quot;/&quot; component =Profile{abut} /&gt;
                    &lt;Route exact path=&quot;/Profile&quot; component = {Profile} /&gt;
                &lt;/BrowserRouter&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre></div><h3 id="三-navlink组件的使用"><a href="#三-navlink组件的使用" class="header-anchor">#</a> 三 NavLink组件的使用</h3> <div class="language- extra-class"><pre class="language-text"><code>需求： 路径选中时使用NavLink组件来替代Link组件

activeStyle: 活跃时（匹配时）的样式
activeClassName: 活跃时添加的class
exact: 是否精准匹配

&lt;NavLink exact to=&quot;/&quot;  activeClassName =  &quot;link-active&quot;&gt;主页&lt;/NavKlink&gt;

&lt;NavLink to=&quot;/about&quot; activeStyle={{ color: 'red', fontsize: '35px'}}&gt;关于&lt;/NavLink&gt;

</code></pre></div><h3 id="四-switch组件应用"><a href="#四-switch组件应用" class="header-anchor">#</a> 四 Switch组件应用</h3> <ol><li>使用场景：只要有一个path匹配上了对应的组件，后续就不会在进行匹配了。</li> <li>路由规则：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;Route exact path=&quot;/&quot; component={Home} /&gt;
&lt;Route path=&quot;/about&quot; component={About} /&gt;
&lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
&lt;Route path=&quot;/:id&quot; component={User} /&gt;
&lt;Route path component={NotMatch} /&gt;

如/about匹配的同时，/:userid也会被匹配到，最后的NoMath组件总是被匹配到。    
</code></pre></div><ul><li>原因： react-router中只要是路径被匹配到的Route对应的组件都会渲染。</li> <li>使用Switch包裹，只匹配第一个，后面不再匹配。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;Switch&gt;
    &lt;Route exact path=&quot;/&quot; component={Home} /&gt;
    &lt;Route path=&quot;/about&quot; component={About} /&gt;
    &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
    &lt;Route path=&quot;/:id&quot; component={User} /&gt;
    &lt;Route path component={NotMatch} /&gt;
&lt;/Switch&gt;
</code></pre></div><h3 id="五-redirect重定向"><a href="#五-redirect重定向" class="header-anchor">#</a> 五 Redirect重定向</h3> <p><code>&lt;Redirect to='/login' /&gt;</code></p> <h2 id="react-router补充"><a href="#react-router补充" class="header-anchor">#</a> react-router补充</h2> <ol><li>路由嵌套</li></ol> <div class="language- extra-class"><pre class="language-text"><code>/home 
/home/news
</code></pre></div><ol start="2"><li>手动路由跳转withRouter</li></ol> <blockquote><p>目前实现跳转主要通过Link，NavLink跳转，通过js代码跳转。</p></blockquote> <ul><li>获取history对象<br> <code>方式一： 如果该组件通过路由跳转，可以从props属性中获取history,location,match</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>方式二： APP组件中获取到history对象，需要使用whithRouter**高阶组件**  
APP组件必须包裹在BrowserRouter或者HashRouter内
APP组件必须使用WithRouter高组件包裹

// 1.不使用Link组件或者NavLink组件实现跳转
joinTo() {
    // 1. 使用的history是通过Route组件传递。
    // 2. 通过Route传递的history对象来实现路径跳转
    this.props.history.push('/about/join')
}

// app.js
jumpToProduct(){
    this.props.history.push('/product')
}
</code></pre></div><ol start="3"><li>参数传递： 动态路由传递， search传递参数， Link中to传入对象。</li></ol> <ul><li>动态路由传递</li></ul> <div class="language- extra-class"><pre class="language-text"><code>将path在Route匹配时写成/detail/:id，那么/detail/abc、/detail/123都可以匹配到该Route，并且进行显示

// APP.js
&lt;NavLink to={`/detail/${id}`}&gt;详情&lt;/NavLink&gt;

&lt;Route path='/detail/:id' component={detail} /&gt;

// detail.js
获取动态路由传递的id参数
&lt;h2&gt;Detail: {match.params.id}&lt;/h2&gt;
</code></pre></div><ul><li>search传递参数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>在Link或NavLink组件通过to属性传递query string

&lt;NavLink to={`/detail2?name=asd&amp;age=18`}&gt;详情2（通过search传参）&lt;/NavLink&gt;
// search获取传递的query
&lt;h2&gt;Detail2: {this.props.location}&lt;/h2&gt;
</code></pre></div><ul><li>Link中的to属性直接传递一个对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// app.js
&lt;NavLink 
    to={{
        pathname: '/detail',
        search: '?name=abc',
        state: info
    }}
&gt;进入详情&lt;/NavLink&gt;

// detail.js
console.log(this.props.location)
</code></pre></div><h2 id="react-router-config"><a href="#react-router-config" class="header-anchor">#</a> react-router-config</h2> <h3 id="一-react-router-config基本配置"><a href="#一-react-router-config基本配置" class="header-anchor">#</a> 一 react-router-config基本配置</h3> <blockquote><p>目前我们所有的路由定义都是直接使用Route组件，并且添加属性来完成的 但是这样的方式会让路由变得非常混乱</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>- 将所有的路由配置放到一个地方进行集中管理，使用: react-router-config来完成
- 安装react-router-config  yarn add react-router-config  配置路由映射关系数组

const routes = [
  { path: '/', component: Home, exact: true },
  { path: '/profile', component: Profile },
  { path: '/detail/:id', component: Detail },
]
// app.js
import { renderRoutes } from 'react-router-config'
import routes from './router'
    render() {
        // ...
        { renderRoutes(routes) }
    }
// about.js
</code></pre></div><h3 id="二-嵌套子路由配置映射关系"><a href="#二-嵌套子路由配置映射关系" class="header-anchor">#</a> 二 嵌套子路由配置映射关系</h3> <div class="language- extra-class"><pre class="language-text"><code>在路由嵌套中配置路由映射关系
const routes = [
  {
    path: '/about',
    component: About,
    route: [
      { 
          path: '/about', 
          component: AboutHistory, 
          exact: true 
      },
      {
        path: '/about/join',
        component: AboutJoin,
      },
    ]
  }
]
// about.js ( 在被Route渲染的组件中: 使用props取出route )
  render() {
     { renderRoutes(this.props.route.route) }
  }

</code></pre></div><h2 id="browserrouter-hashrouter"><a href="#browserrouter-hashrouter" class="header-anchor">#</a> BrowserRouter HashRouter</h2> <p>BrowserRouter：
HashRouter</p> <p>底层原理：底层原理使用H5的history API，不兼容IE9及以下版本<br>
底层原理：使用URL的哈希值，兼容性更好</p> <p>path形式：路径中没有#，localhost:3000/demo/test<br>
path形式：路径包含#，localhost:3000/#/demo/test</p> <p>刷新后对路由state参数的影响 ：没有任何影响，因为state保存在history对象中<br>
刷新后对路由state参数的影响 ：刷新后会导致路由state参数的丢失！</p> <p>备注：HashRouter可以用于解决一些路径错误相关的问题。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Blog/React/LifeCycle.html" class="prev">
        生命周期
      </a></span> <span class="next"><a href="/Blog/React/Redux.html">
        Redux
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/44.36c49c87.js" defer></script>
  </body>
</html>
