<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>核心概念 | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/43.2e2eee59.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/18.bc0ab2ef.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/24.bcb02ed7.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/41.6f245bcc.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/44.36c49c87.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/47.7987c6b9.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/React/" aria-current="page" class="active sidebar-link">基础概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/React/#核心概念" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#jsx简介" class="sidebar-link">JSX简介</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#元素渲染" class="sidebar-link">元素渲染</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#组件与props" class="sidebar-link">组件与Props</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#state与生命周期" class="sidebar-link">state与生命周期</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#事件处理" class="sidebar-link">事件处理</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#条件渲染" class="sidebar-link">条件渲染</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#列表与key" class="sidebar-link">列表与Key</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#状态提升" class="sidebar-link">状态提升</a></li><li class="sidebar-sub-header"><a href="/Blog/React/#组合vs继承" class="sidebar-link">组合VS继承</a></li></ul></li><li><a href="/Blog/React/LifeCycle.html" class="sidebar-link">生命周期</a></li><li><a href="/Blog/React/Router.html" class="sidebar-link">路由</a></li><li><a href="/Blog/React/Redux.html" class="sidebar-link">Redux</a></li><li><a href="/Blog/React/Guidance.html" class="sidebar-link">高级指引</a></li><li><a href="/Blog/React/Hook.html" class="sidebar-link">HooK</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="核心概念"><a href="#核心概念" class="header-anchor">#</a> 核心概念</h2> <h2 id="jsx简介"><a href="#jsx简介" class="header-anchor">#</a> JSX简介</h2> <ol><li>JSX嵌入表达式</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
&lt;h1&gt;
    Hello, {formatName(user)}!
&lt;/h1&gt;
</code></pre></div><ol start="2"><li>JSX也是一个表达式</li> <li>JSX特定属性<br>
使用引号将属性值指定为字符串字面量   <code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;</code>;<br>
使用大括号，将属性值里插入JavaScript表达式 <code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code><br>
使用JSX指定子元素，如果标签里没有内容，用 /&gt; 闭合标签<br>
JSX防注入攻击，React渲染是默认会进行转译，，所有渲染的内容会被转换为字符串<br>
JSX表示对象</li></ol> <h2 id="元素渲染"><a href="#元素渲染" class="header-anchor">#</a> 元素渲染</h2> <ol><li>将一个元素渲染为DOM</li> <li>更新已经渲染的元素</li> <li>React只更需要更新的地方，会将元素和它的子元素与之前的状态进行比较，进行必要的更新。</li></ol> <h2 id="组件与props"><a href="#组件与props" class="header-anchor">#</a> 组件与Props</h2> <ol><li></li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Welcome extends React.Component {
render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
接受唯一带有数据的Props（属性）对象，返回React元素。称为函数组件，本质上为JavaScript函数
</code></pre></div><ol start="2"><li>组件必须大写字母开头</li> <li>组合组件</li> <li>提取组件</li> <li>prop的只读性</li></ol> <blockquote><blockquote><p>组件无论是使用函数函数声明还是通过calss声明，都绝不能修改自身的props。<br>
纯函数： 函数不会尝试更改入参，多次调用下，相同的入参始终返回相同的结果</p></blockquote></blockquote> <div class="language- extra-class"><pre class="language-text"><code>纯函数
	function sum(a, b) {
		return a + b;
	}

	非纯函数
	function withdraw(account, amount) {
		account.total -= amount;
	}
</code></pre></div><ol start="6"><li>无状态组件：一个组件无需管理state，只是纯粹的展示</li></ol> <h2 id="state与生命周期"><a href="#state与生命周期" class="header-anchor">#</a> state与生命周期</h2> <ol><li>state组件私有，完全受控于当前组件</li> <li>state
<ol><li>不能直接修改state</li> <li>state  props更新可能会是异步更新，不要依赖其更新下一个状态</li></ol></li></ol> <blockquote><p>// Wrong<br>
this.setState({<br>
counter: this.state.counter + this.props.increment,<br>
})<br>
可以解决上述问题  setState可以接受一个函数<br>
// Correct<br>
this.setState((state, props) =&gt; ({<br>
counter: state.counter + props.increment<br>
}));</p></blockquote> <ol start="3"><li>数据向下流动：state 派生的任何数据或 UI 只能影响树中“低于”它们的组件</li></ol> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <ol><li><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写</p></li> <li><p>JSX传入函数作为事件处理函数，而不是一个字符串</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>	传统的HTML
	&lt;button onclick=&quot;activateLasers()&quot;&gt;
		Activate Lasers
	&lt;/button&gt;

	React
	&lt;button onClick={activateLasers}&gt;
		Activate Lasers
	&lt;/button&gt;
</code></pre></div><ol start="3"><li><p>React中不能通过返回false的方式阻止默认事件，显示方式e.preventDefault()</p></li> <li><p>React中回调函数的this，class方法不会默认绑定this，如果忘记绑定this指向则为undefined【bind】</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>	onClick={() =&gt; this.handleClick()}
	onClick={this.handleClick}
	handleClick = () =&gt; {
    	console.log('this is:', this);
  	}
</code></pre></div><ol start="5"><li>向事件处理程序传递参数</li></ol> <div class="language- extra-class"><pre class="language-text"><code>	&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
	&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
	两种情况React事件对象e都会被传递，箭头函数方式是显式传递，bind方法为隐式传递
</code></pre></div><h2 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h2> <ol><li>可以使用运算符if或者条件运算符创建元素表现当前状态</li> <li>元素变量	<code>&lt;Greeting isLoggedIn={isLoggedIn} /&gt;</code></li> <li>与运算符&amp;&amp;</li> <li>三目运算符</li> <li>阻止组件渲染<div class="language- extra-class"><pre class="language-text"><code>render直接返回null，不进行渲染  
function WarningBanner(props) {  
	if (!props.warn) {  
	return null;  
}  
&lt;WarningBanner warn={this.state.showWarning} /&gt; 
</code></pre></div></li></ol> <h2 id="列表与key"><a href="#列表与key" class="header-anchor">#</a> 列表与Key</h2> <ol><li>渲染多个组件, 利用map渲染</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li&gt;{number}&lt;/li&gt;
)

ReactDOM.render(
  &lt;ul&gt;{listItems}&lt;/ul&gt;,
  document.getElementById('root')
);
</code></pre></div><ol start="3"><li>基础列表组件 : 每创建一个元素时，必须包含一个特殊的key属性</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;li key={number.toString()}&gt;
      {number}
    &lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre></div><ol start="4"><li>key</li></ol> <ul><li><ol><li>帮助react识别哪些元素改变，给数组中每个元素赋上确定的标识
通常使用数据的id为key
index可以作为key，如果列表顺序会发生变化，不建议使用索引作为key值，会导致性能变差，可能会引起组件状态问题。
如果不显式的指定key，react会默认使用索引作为列表项目的值</li></ol></li> <li><ol start="2"><li>key只有放在就近的数组上下文中才有意义，map()方法中需要设定key属性</li></ol></li> <li><ol start="3"><li>可以在兄弟节点直接必须唯一，可以信息会传递给react，不会传递给组件，	如果组件中需要使用，必须用其他属性名显式传递</li></ol></li> <li><ol start="4"><li>JSX允许在大括号中嵌入任何表达式</li></ol></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function NumberList(props) {
  const numbers = props.numbers;
  return (
    &lt;ul&gt;
      {numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()}
        value={number} /&gt;
      )}
    &lt;/ul&gt;
  );
}
</code></pre></div><h2 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h2> <ol><li>表单元素</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;
class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('你喜欢的风味是: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          选择你喜欢的风味:
          &lt;select value={this.state.value} onChange={this.handleChange}&gt;
            &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
            &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;
            &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
            &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre></div><ol start="2"><li>受控组件</li></ol> <ul><li>React的state成为唯一数据源，渲染表单的React组件，还控制着用户输入过程中的表单发生的操作，。被React以这种方式控制取值的表单输入元素就叫做受控组件。</li> <li>输入值始终由React的state驱动</li></ul> <ol start="3"><li>处理多个输入：可以给每个元素添加name属性，处理函数根据e.target.name执行操作</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };

    this.handleInputChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.name === 'isGoing' ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value
    });
  }

  render() {
    return (
      &lt;form&gt;
        &lt;label&gt;
          参与:
          &lt;input
            name=&quot;isGoing&quot;
            type=&quot;checkbox&quot;
            checked={this.state.isGoing}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;label&gt;
          来宾人数:
          &lt;input
            name=&quot;numberOfGuests&quot;
            type=&quot;number&quot;
            value={this.state.numberOfGuests}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre></div><ol start="4"><li>受控组件输入空值</li></ol> <ul><li>受控组件指定的value，props会阻止用户更改输入，如果指定value，但输入仍可以编辑，可能意外的将value设置成了undefined，null</li></ul> <h2 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升</h2> <ol><li>将多个组件共用的state向上移动到它们最近共同的父组件中，实现共享state依靠自上而下的数据流</li></ol> <h2 id="组合vs继承"><a href="#组合vs继承" class="header-anchor">#</a> 组合VS继承</h2> <ol><li>组合
包含关系
特例关系</li> <li>继承
无需使用继承构建组件</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/Blog/React/LifeCycle.html">
        生命周期
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/43.2e2eee59.js" defer></script>
  </body>
</html>
