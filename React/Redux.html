<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redux | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/18.bc0ab2ef.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/24.bcb02ed7.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/41.6f245bcc.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/43.2e2eee59.js"><link rel="prefetch" href="/Blog/assets/js/44.36c49c87.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/47.7987c6b9.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/React/" aria-current="page" class="sidebar-link">基础概念</a></li><li><a href="/Blog/React/LifeCycle.html" class="sidebar-link">生命周期</a></li><li><a href="/Blog/React/Router.html" class="sidebar-link">路由</a></li><li><a href="/Blog/React/Redux.html" aria-current="page" class="active sidebar-link">Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#基本用法-api" class="sidebar-link">基本用法 API</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#基本用法-流程" class="sidebar-link">基本用法 流程</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#中间与异步" class="sidebar-link">中间与异步</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#react-redux用法" class="sidebar-link">react-redux用法</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Redux.html#react-router" class="sidebar-link">react-router</a></li></ul></li><li><a href="/Blog/React/Guidance.html" class="sidebar-link">高级指引</a></li><li><a href="/Blog/React/Hook.html" class="sidebar-link">HooK</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h2> <h4 id="javascript状态容器，提供可预测化的状态管理"><a href="#javascript状态容器，提供可预测化的状态管理" class="header-anchor">#</a> JavaScript状态容器，提供可预测化的状态管理</h4> <p>web应用是一个状态机，视图与状态是一一对应的所有的状态都保存在一个对象里面</p> <h2 id="基本用法-api"><a href="#基本用法-api" class="header-anchor">#</a> 基本用法 API</h2> <ol><li>store（容器）保存数据的地方，利用createStore生成store</li></ol> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux'
const store = createStore(fn)
接受另一个函数作为参数，返回新生成的store对象
</code></pre></div><ol start="2"><li>state组件内部的状态，store包含的所有对象，得到数据store.getState()</li></ol> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(fn);

const state = store.getState();
一个state只对应一个view
</code></pre></div><ol start="3"><li>action组件动作，相应的改变组件内部的状态值（ View 发出的通知，表示 State 应该要发生变化了）</li></ol> <div class="language- extra-class"><pre class="language-text"><code>	state的变化会导致view的变化，state的变化必须是view导致
	Action 就是 View 发出的通知，表示 State 应该要发生变化了。
	const action = {
  		type: 'ADD_TODO',
  		payload: 'Learn Redux'
	};
	Actioc会运送数据到 Store


    view发送多少信息，就会有多少的action，定义一个action函数 。此时就是action creator
	const ADD_TODO = '添加 TODO';
	function addTodo(text) {
  	return {
    	type: ADD_TODO,
    	text
  		}
	}
	const action = addTodo('Learn Redux');
</code></pre></div><ol start="4"><li>dispatch发出相应的动作，store.dispatch( )，是view发出action的唯一方法</li></ol> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(fn);

store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
</code></pre></div><ol start="5"><li>Reducer是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const reducer = function (state, action) {
  // ...
  return new_state;
}



store收到Action的时候，必须给出一个新的state，这样view才会变化。这种 State 的计算过程就叫做 Reducer。
const defaultState = 0;
const reducer = (state = defaultState, action) =&gt; {
  switch (action.type) {
    case 'ADD':
      return state + action.payload;
    default: 
      return state;
  }
};

const state = reducer(1, {
  type: 'ADD',
  payload: 2
});
</code></pre></div><ol start="6"><li>store.subscribe() 设置监听方法，一旦state发生变化，就会自动执行这个函数要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux';
const store = createStore(reducer);
store.subscribe(listener);

function listerner() {
  let newState = store.getState();
  component.setState(newState);   
}
</code></pre></div><ol start="7"><li>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let unsubscribe = store.subscribe(() =&gt;
  console.log(store.getState())
);

unsubscribe();
</code></pre></div><h2 id="基本用法-流程"><a href="#基本用法-流程" class="header-anchor">#</a> 基本用法 流程</h2> <p>图示<br> <img src="/Blog/assets/img/redux.89734f45.png" alt="redux"><br> <code>store</code> ➡️ <code>dispatch</code> ➡️ <code>action</code> ⬅️ <code>reducer</code></p> <p>文字描述</p> <ol><li>用户发出 Action。   <code>store.dispatch(action);</code></li> <li>Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State,<code>let nextState = todoApp(previousState, action);</code></li> <li>State 一旦有变化，Store 就会调用监听函数
<code>// 设置监听函数 store.subscribe(listener);</code></li> <li>istener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。
function listerner() {
let newState = store.getState();
component.setState(newState);<br>
}</li></ol> <p>注意点</p> <div class="language- extra-class"><pre class="language-text"><code>Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法

// State 是一个对象
function reducer(state, action) {
  return Object.assign({}, state, { thingToChange });
  // 或者
  return { ...state, ...newState };
}

// State 是一个数组
function reducer(state, action) {
  return [...state, newItem];
}
</code></pre></div><h2 id="中间与异步"><a href="#中间与异步" class="header-anchor">#</a> 中间与异步</h2> <h4 id="中间件是一个函数，对store-dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能"><a href="#中间件是一个函数，对store-dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能" class="header-anchor">#</a> 中间件是一个函数，对store.dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能</h4> <div class="language- extra-class"><pre class="language-text"><code>let next = store.dispatch;
store.dispatch = function dispatchAndLog(action) {
  console.log('dispatching', action);
  next(action);
  console.log('next state', store.getState());
}
</code></pre></div><h4 id="中间件的用法"><a href="#中间件的用法" class="header-anchor">#</a> 中间件的用法</h4> <ul><li>ctreate可以接受整个应用的初试状态作为参数</li> <li>中间件讲究有次序</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { applyMiddleware, createStore } from 'redux';
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  applyMiddleware(logger)
);
</code></pre></div><ul><li>applyMiddleware（）方法，redux的原生方法，将所有的中间件组成一个数组。依次执行所有的中间件，全部被放进一个chaid数组中，然后嵌套执行，最后执行store.dispatch</li></ul> <h4 id="异步操作的思路"><a href="#异步操作的思路" class="header-anchor">#</a> 异步操作的思路</h4> <ol><li>同步操作只要发出一种action，异步操作的差别是它要发出三种action</li></ol> <div class="language- extra-class"><pre class="language-text"><code>操作发起的action
操作成功时的action
操作失败时的action
// 写法一：名称相同，参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
				state
					let state = {
 // ... 
isFetching: true,
didInvalidate: true,
lastUpdated: 'xxxxxxx'
};
</code></pre></div><ol start="2"><li>State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。</li> <li>操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染
操作结束后，再送出一个 Action，触发 State 更新为&quot;操作结束&quot;状态，View 再一次重新渲染</li></ol> <h4 id="异步操作的解决方案"><a href="#异步操作的解决方案" class="header-anchor">#</a> 异步操作的解决方案</h4> <ol><li>redux-thunk
<ul><li>Action Creator返回函数，然后使用redux-thunk中间件改造store.dispatch</li> <li>使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。</li></ul></li> <li>redu-propmise这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数
<ul><li>Action Creator 返回一个 Promise 对象，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)），但 reject 以后不会有任何动作</li> <li>Action 对象的payload属性是一个 Promise 对象。需要从redux-actions模块引入createAction方法。如果 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。</li></ul></li></ol> <h2 id="react-redux用法"><a href="#react-redux用法" class="header-anchor">#</a> react-redux用法</h2> <h4 id="注意点：一个组件既有ui又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个ui-组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图"><a href="#注意点：一个组件既有ui又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个ui-组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图" class="header-anchor">#</a> 注意点：一个组件既有UI又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图</h4> <h4 id="ui组件（纯组件）"><a href="#ui组件（纯组件）" class="header-anchor">#</a> UI组件（纯组件）</h4> <p>只负责 UI 的呈现，不带有任何业务逻辑<br>
没有状态（即不使用this.state这个变量）<br>
所有数据都由参数（this.props）提供<br>
不使用任何 Redux 的 API</p> <div class="language- extra-class"><pre class="language-text"><code>	const Title =value =&gt; &lt;h1&gt;{value}&lt;/h1&gt;;
</code></pre></div><h4 id="容器组件"><a href="#容器组件" class="header-anchor">#</a> 容器组件</h4> <ol><li>负责管理数据和业务逻辑，不负责 UI 的呈现带有内部状态使用 Redux 的 API</li></ol> <h4 id="connect-连接ui，容器"><a href="#connect-连接ui，容器" class="header-anchor">#</a> connect()  连接UI，容器</h4> <p>（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数</p> <p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。<code>import { connect } from 'react-redux'</code></p> <div class="language- extra-class"><pre class="language-text"><code>const VisibleTodoList = connect(
  mapStateToProps,（前者负责输入逻辑，即将state映射到 UI 组件的参数（props））
  mapDispatchToProps（者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action）
)(TodoList)
</code></pre></div><h4 id="mapstatetoprops-建立一个从（外部的）state对象到（ui-组件的）props对象的映射关系。"><a href="#mapstatetoprops-建立一个从（外部的）state对象到（ui-组件的）props对象的映射关系。" class="header-anchor">#</a> mapStateToProps() 建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。</h4> <ol><li>mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const mapStateToProps = (state) =&gt; {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
</code></pre></div><ol start="2"><li>mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const getVisibleTodos = (todos, filter) =&gt; {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t =&gt; t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t =&gt; !t.completed)
    default:
      throw new Error('Unknown filter: ' + filter)
  }
}
</code></pre></div><ol start="3"><li><p>mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p></li> <li><p>connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>const mapStateToProps = (state, ownProps) =&gt; {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}
</code></pre></div><h4 id="mapdispatchtoprops"><a href="#mapdispatchtoprops" class="header-anchor">#</a> mapDispatchToProps()</h4> <p>建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p> <ol><li>函数<br>
dispatch和ownProps（容器组件的props对象）两个参数mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const mapDispatchToProps = (
  dispatch,
  ownProps
) =&gt; {
  return {
    onClick: () =&gt; {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}
</code></pre></div><ol start="2"><li>对象<br>
键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const mapDispatchToProps = {
  onClick: (filter) =&gt; {
    type: 'SET_VISIBILITY_FILTER',
    filter: filter
  };
}
</code></pre></div><h4 id="provider"><a href="#provider" class="header-anchor">#</a> Provider</h4> <p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。</p> <p>一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。</p> <p>React-Redux 提供Provider组件，可以让容器组件拿到state</p> <div class="language- extra-class"><pre class="language-text"><code>import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
document.getElementById('root') 
</code></pre></div><h2 id="react-router"><a href="#react-router" class="header-anchor">#</a> react-router</h2> <ul><li>使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const Root = ({ store }) =&gt; (
  &lt;Provider store={store}&gt;
    &lt;Router&gt;
      &lt;Route path=&quot;/&quot; component={App} /&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;
);
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Blog/React/Router.html" class="prev">
        路由
      </a></span> <span class="next"><a href="/Blog/React/Guidance.html">
        高级指引
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/18.bc0ab2ef.js" defer></script>
  </body>
</html>
