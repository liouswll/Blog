<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hook | lious</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="前端开发空间站">
    <link rel="preload" href="/Blog/assets/css/0.styles.16d8b4f8.css" as="style"><link rel="preload" href="/Blog/assets/js/app.9c47bd80.js" as="script"><link rel="preload" href="/Blog/assets/js/2.b786c2ed.js" as="script"><link rel="preload" href="/Blog/assets/js/41.6f245bcc.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.2ae6b466.js"><link rel="prefetch" href="/Blog/assets/js/11.533bbb72.js"><link rel="prefetch" href="/Blog/assets/js/12.8e74b9fc.js"><link rel="prefetch" href="/Blog/assets/js/13.2be3647b.js"><link rel="prefetch" href="/Blog/assets/js/14.1badd55b.js"><link rel="prefetch" href="/Blog/assets/js/15.f7f64fd6.js"><link rel="prefetch" href="/Blog/assets/js/16.72a686a6.js"><link rel="prefetch" href="/Blog/assets/js/17.db6d94f8.js"><link rel="prefetch" href="/Blog/assets/js/18.bc0ab2ef.js"><link rel="prefetch" href="/Blog/assets/js/19.e02c1cba.js"><link rel="prefetch" href="/Blog/assets/js/20.d91c50f5.js"><link rel="prefetch" href="/Blog/assets/js/21.22b161ae.js"><link rel="prefetch" href="/Blog/assets/js/22.bc2dea31.js"><link rel="prefetch" href="/Blog/assets/js/23.8e66fc0e.js"><link rel="prefetch" href="/Blog/assets/js/24.bcb02ed7.js"><link rel="prefetch" href="/Blog/assets/js/25.086b542b.js"><link rel="prefetch" href="/Blog/assets/js/26.b4fa9650.js"><link rel="prefetch" href="/Blog/assets/js/27.56fc3609.js"><link rel="prefetch" href="/Blog/assets/js/28.482e48d5.js"><link rel="prefetch" href="/Blog/assets/js/29.08475c58.js"><link rel="prefetch" href="/Blog/assets/js/3.686b262b.js"><link rel="prefetch" href="/Blog/assets/js/30.ba2aca8b.js"><link rel="prefetch" href="/Blog/assets/js/31.5d7b81c9.js"><link rel="prefetch" href="/Blog/assets/js/32.72d44b49.js"><link rel="prefetch" href="/Blog/assets/js/33.25e091aa.js"><link rel="prefetch" href="/Blog/assets/js/34.0b495ba3.js"><link rel="prefetch" href="/Blog/assets/js/35.0c41c066.js"><link rel="prefetch" href="/Blog/assets/js/36.5cb79c2b.js"><link rel="prefetch" href="/Blog/assets/js/37.ad8db7c0.js"><link rel="prefetch" href="/Blog/assets/js/38.1f99eb01.js"><link rel="prefetch" href="/Blog/assets/js/39.b05cd399.js"><link rel="prefetch" href="/Blog/assets/js/4.94ea306f.js"><link rel="prefetch" href="/Blog/assets/js/40.ec81b87a.js"><link rel="prefetch" href="/Blog/assets/js/42.2a727e6b.js"><link rel="prefetch" href="/Blog/assets/js/43.2e2eee59.js"><link rel="prefetch" href="/Blog/assets/js/44.36c49c87.js"><link rel="prefetch" href="/Blog/assets/js/45.cb2389f6.js"><link rel="prefetch" href="/Blog/assets/js/46.6f746980.js"><link rel="prefetch" href="/Blog/assets/js/47.7987c6b9.js"><link rel="prefetch" href="/Blog/assets/js/48.15d01434.js"><link rel="prefetch" href="/Blog/assets/js/49.728714a6.js"><link rel="prefetch" href="/Blog/assets/js/5.c5721a11.js"><link rel="prefetch" href="/Blog/assets/js/6.99fdf330.js"><link rel="prefetch" href="/Blog/assets/js/7.f8ea1854.js"><link rel="prefetch" href="/Blog/assets/js/8.f72b32ca.js"><link rel="prefetch" href="/Blog/assets/js/9.9a3b5fa5.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.16d8b4f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">lious</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Blog/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/Blog/es6/" class="nav-link">
  ES6
</a></div><div class="nav-item"><a href="/Blog/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/Blog/React/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/Blog/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/Blog/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/Blog/Websocket/" class="nav-link">
  Websocket
</a></div><div class="nav-item"><a href="/Blog/Http/" class="nav-link">
  HTTP
</a></div><div class="nav-item"><a href="/Blog/Difficulties/" class="nav-link">
  前端难点集中
</a></div><div class="nav-item"><a href="/Blog/Algorithm/" class="nav-link">
  前端算法
</a></div><div class="nav-item"><a href="/Blog/Node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/Blog/Plan/" class="nav-link">
  PLAN
</a></div><div class="nav-item"><a href="/Blog/Type-Script/" class="nav-link">
  Type-Script
</a></div><div class="nav-item"><a href="/Blog/Gu/" class="nav-link">
  GU
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/React/" aria-current="page" class="sidebar-link">基础概念</a></li><li><a href="/Blog/React/LifeCycle.html" class="sidebar-link">生命周期</a></li><li><a href="/Blog/React/Router.html" class="sidebar-link">路由</a></li><li><a href="/Blog/React/Redux.html" class="sidebar-link">Redux</a></li><li><a href="/Blog/React/Guidance.html" class="sidebar-link">高级指引</a></li><li><a href="/Blog/React/Hook.html" aria-current="page" class="active sidebar-link">HooK</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/React/Hook.html#hook" class="sidebar-link">Hook</a></li><li class="sidebar-sub-header"><a href="/Blog/React/Hook.html#react-hook" class="sidebar-link">React Hook</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="hook"><a href="#hook" class="header-anchor">#</a> Hook</h2> <ul><li><p>React Hooks要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享</p></li> <li><p>React Hook</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { useState } from 'React';

function Example() {
  // Declare a new state variable, which we'll call &quot;count&quot;
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

</code></pre></div><ul><li>React State</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre></div><p><strong>在React Hook中，class Example组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都得益于useState这个Hook，useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并</strong></p> <h2 id="react-hook"><a href="#react-hook" class="header-anchor">#</a> React Hook</h2> <ul><li>动机：在组件之间复用状态逻辑很难，复杂组件变得难以理解，难以理解的 class。</li> <li>语法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React, { useState } from 'React';
const [count, setCount] = useState(0);

等价于
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
  };
}
</code></pre></div><ul><li><p>useState参数<br>
传入了0作为useState的参数，这个参数的数值会被当成count初始值。当然此参数<strong>不限于传递数字以及字符串，可以传入一个对象当成初始的state</strong>。如果state需要储存多个变量的值，那么调用多次useState即可</p></li> <li><p>useState返回值<br>
返回值为：当前 state 以及更新 state 的函数，这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。看到[count, setCount]很容易就能明白这是ES6的解构数组的写法。相当于以下代码</p> <div class="language- extra-class"><pre class="language-text"><code>let _useState = useState(0);// 返回一个有两个元素的数组
let count = _useState[0];// 数组里的第一个值
let setCount = _useState[1];// 数组里的第二个值
</code></pre></div></li> <li><p>读取状态值<br>
以前<code>&lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;</code><br>
现在<code>&lt;p&gt;You clicked {count} times&lt;/p&gt;</code></p></li> <li><p>更新状态</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>以前
&lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
    Click me
 &lt;/button&gt;

现在
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;
    Click me
&lt;/button&gt;

</code></pre></div><h4 id="声明多个state变量"><a href="#声明多个state变量" class="header-anchor">#</a> 声明多个state变量</h4> <ul><li>一个组件中多次使用state hook</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function ExampleWithManyStates() {
  // 声明多个 state 变量！
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}
</code></pre></div><p>React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的</p> <h4 id="hook-规则"><a href="#hook-规则" class="header-anchor">#</a> Hook 规则</h4> <ol><li>只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li> <li>只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook。</li></ol> <blockquote><p>这两条规则出现的原因是，我们可以在单个组件中使用多个State Hook 或 Effect Hook，React 靠的是 Hook 调用的顺序来知道哪个 state 对应哪个useStat</p></blockquote> <h4 id="effect-hook使用-effect在组件渲染后执行即可"><a href="#effect-hook使用-effect在组件渲染后执行即可" class="header-anchor">#</a> Effect Hook使用 -&gt; Effect在组件渲染后执行即可</h4> <ul><li>用法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });
</code></pre></div><blockquote><p>如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</p></blockquote> <h4 id="清除副作用"><a href="#清除副作用" class="header-anchor">#</a> 清除副作用</h4> <p>有时候对于一些副作用，我们是需要去清除的，比如我们有个需求需要轮询向服务器请求最新状态，那么我们就需要在卸载的时候，清理掉轮询的操作。</p> <div class="language- extra-class"><pre class="language-text"><code>  常规
  componentDidMount() {
    this.pollingNewStatus()
  }

  componentWillUnmount() {
    this.unPollingNewStatus()
  }

  react hook
  useEffect(() =&gt; {
      pollingNewStatus()
      //告诉React在每次渲染之前都先执行cleanup()
      return function cleanup() {
        unPollingNewStatus()
      };
    });

useEffect其实是每次渲染之前都会去执行cleanup(),而componentWillUnmount只会执行一次
</code></pre></div><h4 id="effect性能优化"><a href="#effect性能优化" class="header-anchor">#</a> Effect性能优化</h4> <ul><li>useEffect其实是每次更新都会执行，在某些情况下会导致性能问题。那么我们可以通过跳过 Effect 进行性能优化。在class组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决</li></ul> <div class="language- extra-class"><pre class="language-text"><code>componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
</code></pre></div><ul><li>在Effect中，我们可以通过增加Effect的第二个参数即可，如果没有变化，则跳过更新</li></ul> <div class="language- extra-class"><pre class="language-text"><code>useEffect(() =&gt; {
  document.title = `You clicked ${count} times`;
}, [count]); // 仅在 count 更改时更新

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Blog/React/Guidance.html" class="prev">
        高级指引
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.9c47bd80.js" defer></script><script src="/Blog/assets/js/2.b786c2ed.js" defer></script><script src="/Blog/assets/js/41.6f245bcc.js" defer></script>
  </body>
</html>
