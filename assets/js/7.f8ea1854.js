(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{379:function(n,a,t){n.exports=t.p+"assets/img/factory.0a5abc32.png"},380:function(n,a,t){n.exports=t.p+"assets/img/functionGz.51b4fc12.png"},381:function(n,a,t){n.exports=t.p+"assets/img/prototypeYX.c8974d40.png"},382:function(n,a,t){n.exports=t.p+"assets/img/prototypeYXERROR.c7b10b2f.png"},431:function(n,a,t){"use strict";t.r(a);var e=t(43),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"工厂模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[n._v("#")]),n._v(" 工厂模式")]),n._v(" "),e("p",[e("img",{attrs:{src:t(379),alt:"factory"}})]),n._v(" "),e("h2",{attrs:{id:"构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[n._v("#")]),n._v(" 构造函数")]),n._v(" "),e("ul",[e("li",[n._v("构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。")]),n._v(" "),e("li",[n._v("构造函数和普通函数的区别就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。")])]),n._v(" "),e("h4",{attrs:{id:"执行流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[n._v("#")]),n._v(" 执行流程")]),n._v(" "),e("ol",[e("li",[n._v("立刻创建一个新的对象")]),n._v(" "),e("li",[n._v("将新建的对象设置为函数中this, 在构造函数中可以使用this来引用新建的对象")]),n._v(" "),e("li",[n._v("逐行执行函数中的代码")]),n._v(" "),e("li",[n._v("将新建的对象作为返回值返回\n"),e("img",{attrs:{src:t(380),alt:"functionGz"}})])]),n._v(" "),e("h4",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[n._v("#")]),n._v(" "),e("strong",[n._v("问题")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Person(name,age,job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = new Function("alert(this.name)")\n}\n每个构造函数上的Person实例，都包含一个不同的Function实例(以显示name属性)的本质。\n以这种方式创建函数，会导致不同的作用域链和标识符解析。\nperson1.sayName  == person2.sayName  // false\n\n——解决\n创建两个完成同样任务的Function实例没有必要，有this对象在，不用在执行代码前就把函数绑定到特定的对象上。\nfunction Person(name,age,job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName；\n}\nfunction sayName(){\n    alert(this.name)\n}\n')])])]),e("h2",{attrs:{id:"原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[n._v("#")]),n._v(" 原型模式")]),n._v(" "),e("p",[e("img",{attrs:{src:t(381),alt:"prototypeYX"}})]),n._v(" "),e("h4",{attrs:{id:"问题1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题1"}},[n._v("#")]),n._v(" 问题1")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("由其共享的本性导致\nfunction Person() {\n\n}\nPerson.prototype = {\n    name: 'as',\n    age: 11,\n    job: 'asda',\n    sayName: function(){\n        alert(this.name);\n    }\n}\n把Person.property设置为以对象字面量形式创建新对象。结果相同但其constructor属性不再指向Person\n\n每创建一个函数，就会同时创建它的prototype对象，对象会自动获取constructor属性。这里本质上完全\n重写了prototype对象，constructor属性也变成了新对象的constructor属性（指向object构造函数）\nPerson.prototype = {\n    constructor： Person,\n    name: 'as',\n    age: 11,\n    job: 'asda',\n    sayName: function(){\n        alert(this.name);\n    }\n}\n\n")])])]),e("h4",{attrs:{id:"问题2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题2"}},[n._v("#")]),n._v(" 问题2")]),n._v(" "),e("p",[e("img",{attrs:{src:t(382),alt:"prototypeYXERROR"}})]),n._v(" "),e("h2",{attrs:{id:"组合使用构造函数和原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合使用构造函数和原型模式"}},[n._v("#")]),n._v(" 组合使用构造函数和原型模式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(name,age,job){\nthis.name = name;\nthis.age = age;\nthis.job = job;\nthis.firend = ['ahao','ada'];\n}\nPerson.prototype = {\nconstructor: Person,\nsayName:function(){\nconsole.log(this.name);\n}\n};\nvar p1 = new Person('wh',24,'web开发');\nvar p2 = new Person('lsf',47,'超市上班');\n\np1.firend.push('asong');\nconsole.log(p1.firend); // [\"ahao\", \"ada\", \"asong\"]\nconsole.log(p2.firend); // [\"ahao\", \"ada\"]\nconsole.log(p1.firend === p2.firend); // false\nconsole.log(p1.sayName === p2.sayName); // true\n")])])]),e("h2",{attrs:{id:"动态原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态原型模式"}},[n._v("#")]),n._v(" 动态原型模式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Person(name, age, job){\n    // 属性\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    // 方法\n    if(typeOf this.sayName != "function"){\n        Person.prototype.sayName = finction(){\n            alert(this.name);\n        }\n    }\n}\n')])])]),e("h2",{attrs:{id:"寄生构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄生构造函数"}},[n._v("#")]),n._v(" 寄生构造函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("基本思想：创建一个构造函数，该函数仅仅封装创建的对象的代码，然后再返回新创建的对象。\nfunction Person(){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function(){\n        alert(this.name)\n    };\n    return o;\n}\nvar friend = new Person('a', 12, '教师')\nfriend.sayName(); // a\n\n返回的对象和构造函数或者与构造函数的原型属性之间没有关系，也就是说，构造函数返回的对象\n与构造函数在外部创建的对象没有什么不同。不能依赖insstanceOf操作符确定对象类型。\n")])])]),e("h2",{attrs:{id:"稳妥构造函数模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#稳妥构造函数模式"}},[n._v("#")]),n._v(" 稳妥构造函数模式")]),n._v(" "),e("ul",[e("li",[n._v("与寄生构造函数类似。有两点不同：")])]),n._v(" "),e("blockquote",[e("p",[n._v("1.创建对象的实例方法不引用this。"),e("br"),n._v("\n2.不使用new操作符调用构造函数")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person(){\n    // 创建返回的对象\n    var o = new Object()\n    // 定义私有变量和函数\n\n    // 添加方法\n    o.sayName = function(){\n        alert(name)\n    }\n    // 返回对象\n    return o;\n}\n\n这种模式创建的对象中，除了sayName()方法之外，没有其他的办法访问name值。\nvar friend = Person('a', 12, '教师');\nfriend.sayName(); // a\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);