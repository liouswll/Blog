(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{377:function(t,o,r){t.exports=r.p+"assets/img/prototypeL.71a83974.png"},378:function(t,o,r){t.exports=r.p+"assets/img/protoL.c4010af6.png"},433:function(t,o,r){"use strict";r.r(o);var e=r(43),p=Object(e.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("_proto_")]),t._v(" 是每个对象都有的属性；"),e("strong",[t._v("prototype")]),t._v("是构造函数的属性；指向同一个对象")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function F(){}\nvar f = new F();\nf._proto_ === F.prototype; // true\n")])])]),e("p",[e("img",{attrs:{src:r(377),alt:"prototypeL"}})]),t._v(" "),e("ol",[e("li",[t._v("首先在对象自身上查找是否有该属性，如果有，返回结果")]),t._v(" "),e("li",[t._v("如果没有，就去对象的原型上进行查找， 如果有，返回结果")]),t._v(" "),e("li",[t._v("如果没有，就沿着原型链继续往上查找，直到Object.prototype原型上即可,如果有，返回结果。")]),t._v(" "),e("li",[t._v("如果Object.prototype原型上也没有，返回undefined")])]),t._v(" "),e("blockquote",[e("blockquote")]),t._v(" "),e("ul",[e("li",[t._v("所有函数都有一个prototype指针，指向原型对象，如图中的Foo的prototype指针。prototype指针的意义是，当我们使用这个构造函数new出新对象的时候，新对象的原型是谁。")]),t._v(" "),e("li",[t._v("构造函数的prototype所指向的原型对象有一个constructor指针，指回构造函数。如图中Foo.prototype的- - constructor指针指向Foo。constructor指针有助于我们找到一个对象的构造函数是谁。")]),t._v(" "),e("li",[t._v("__proto__每个对象都有，js在new一个对象的时候，会将它的__proto__指向构造函数的prototype指向的那个对象。在上图中，f1、f2这些实例对象的__proto__都指向了Foo.prototype。")]),t._v(" "),e("li",[t._v("如果一个对象的__proto__指向了另一个对象，那么前者就继承了后者的所有属性。")])]),t._v(" "),e("p",[e("img",{attrs:{src:r(378),alt:"protoL"}})])])}),[],!1,null,null,null);o.default=p.exports}}]);