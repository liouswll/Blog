(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{439:function(t,e,n){"use strict";n.r(e);var s=n(43),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"_1-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-hook"}},[t._v("#")]),t._v(" 1. Hook")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("React Hooks要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享")])]),t._v(" "),n("li",[n("p",[t._v("React Hook")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { useState } from 'React';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n")])])]),n("ul",[n("li",[t._v("React State")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n\n")])])]),n("p",[n("strong",[t._v("在React Hook中，class Example组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都得益于useState这个Hook，useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并")])]),t._v(" "),n("h2",{attrs:{id:"_2-react复用状态逻辑的解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-react复用状态逻辑的解决方案"}},[t._v("#")]),t._v(" 2. React复用状态逻辑的解决方案")]),t._v(" "),n("ul",[n("li",[t._v("Mixin -> 高阶组件 -> Render Props -> Hook")])]),t._v(" "),n("h4",{attrs:{id:"mixin到高阶组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mixin到高阶组件"}},[t._v("#")]),t._v(" Mixin到高阶组件")]),t._v(" "),n("ul",[n("li",[t._v("Mixin继承看作是通过扩展收集功能的一种途径。.我们定义的每一个新的对象都有一个原型，从中它可以继承更多的属性，原型可以从其他对象继承而来，但是更重要的是，能够为任意数量的对象定义属性，我们可以利用这一事实来促进功能重用。\n"),n("blockquote",[n("p",[t._v("缺点\n不同mixin可能会相互依赖，耦合性太强，导致后期维护成本过高"),n("br"),t._v("\nmixin中的命名可能会冲突，无法使用同一命名的mixin"),n("br"),t._v("\nmixin即使开始很简单，它们会随着业务场景增多，时间的推移产生滚雪球式的复杂化")])])])]),t._v(" "),n("h4",{attrs:{id:"高阶组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),n("ul",[n("li",[t._v("高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式")]),t._v(" "),n("li",[t._v("高阶组件可以看做是装饰者模式(Decorator Pattern)在React的实现。装饰者模式: 动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。")])]),t._v(" "),n("h4",{attrs:{id:"装饰者模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[t._v("#")]),t._v(" 装饰者模式")]),t._v(" "),n("ol",[n("li",[t._v("装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。")]),t._v(" "),n("li",[t._v("这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。")])]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("高阶组件动态给其他组件增加日志打印功能")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n\n")])])]),n("h4",{attrs:{id:"render-props"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#render-props"}},[t._v("#")]),t._v(" Render Props")]),t._v(" "),n("ul",[n("li",[t._v("React 组件之间使用一个值为函数的 prop 共享代码的简单技术。")]),t._v(" "),n("li",[t._v("具有 Render Props 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      <img src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} />\n    );\n  }\n}\n——————————————————————————————————————————————————————\nclass Mouse extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>\n\n        {/*\n          Instead of providing a static representation of what <Mouse> renders,\n          use the `render` prop to dynamically determine what to render.\n        */}\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n————————————————————————————————————————————————————\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Move the mouse around!</h1>\n        <Mouse render={mouse => (\n          <Cat mouse={mouse} />\n        )}/>\n      </div>\n    );\n  }\n}\n")])])]),n("p",[t._v("简写如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Class  Mouse extends React.component{\n   ...\n   {this.props.render(this.state)}\n   ...\n}\n\n......\n<Mouse render={mouse => (\n          <Cat mouse={mouse} />\n        )}/>\n")])])]),n("p",[t._v("在使用Mouse组件的时候，通过一个render属性，传递一个可用组件Cat给父组件Mouse，而在Mouse组件中，可以将本身的state对象传递给Cat组件，Cat组件中的mouse属性的值与Mouse父组件中的state相同。"),n("strong",[t._v("简单来说就是父组件可以将自己的state传递给子组件，而子组件可以根据父组件的state对象，来进行render")])]),t._v(" "),n("h4",{attrs:{id:"react-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[t._v("#")]),t._v(" React Hook")]),t._v(" "),n("ul",[n("li",[t._v("动机：在组件之间复用状态逻辑很难，复杂组件变得难以理解，难以理解的 class。")]),t._v(" "),n("li",[t._v("语法：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState } from 'React';\nconst [count, setCount] = useState(0);\n\n等价于\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n  };\n}\n")])])]),n("ul",[n("li",[n("p",[t._v("useState参数"),n("br"),t._v("\n传入了0作为useState的参数，这个参数的数值会被当成count初始值。当然此参数"),n("strong",[t._v("不限于传递数字以及字符串，可以传入一个对象当成初始的state")]),t._v("。如果state需要储存多个变量的值，那么调用多次useState即可")])]),t._v(" "),n("li",[n("p",[t._v("useState返回值"),n("br"),t._v("\n返回值为：当前 state 以及更新 state 的函数，这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。看到[count, setCount]很容易就能明白这是ES6的解构数组的写法。相当于以下代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let _useState = useState(0);// 返回一个有两个元素的数组\nlet count = _useState[0];// 数组里的第一个值\nlet setCount = _useState[1];// 数组里的第二个值\n")])])])]),t._v(" "),n("li",[n("p",[t._v("读取状态值"),n("br"),t._v("\n以前"),n("code",[t._v("<p>You clicked {this.state.count} times</p>")]),n("br"),t._v("\n现在"),n("code",[t._v("<p>You clicked {count} times</p>")])])]),t._v(" "),n("li",[n("p",[t._v("更新状态")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("以前\n<button onClick={() => this.setState({ count: this.state.count + 1 })}>\n    Click me\n </button>\n\n现在\n<button onClick={() => setCount(count + 1)}>\n    Click me\n</button>\n\n")])])]),n("h5",{attrs:{id:"声明多个state变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#声明多个state变量"}},[t._v("#")]),t._v(" 声明多个state变量")]),t._v(" "),n("ul",[n("li",[t._v("一个组件中多次使用state hook")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function ExampleWithManyStates() {\n  // 声明多个 state 变量！\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n  // ...\n}\n")])])]),n("p",[t._v("React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的")]),t._v(" "),n("h5",{attrs:{id:"hook-规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook-规则"}},[t._v("#")]),t._v(" Hook 规则")]),t._v(" "),n("ol",[n("li",[t._v("只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。")]),t._v(" "),n("li",[t._v("只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook。")])]),t._v(" "),n("blockquote",[n("p",[t._v("这两条规则出现的原因是，我们可以在单个组件中使用多个State Hook 或 Effect Hook，React 靠的是 Hook 调用的顺序来知道哪个 state 对应哪个useStat")])]),t._v(" "),n("h5",{attrs:{id:"effect-hook使用-effect在组件渲染后执行即可"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#effect-hook使用-effect在组件渲染后执行即可"}},[t._v("#")]),t._v(" Effect Hook使用 -> Effect在组件渲染后执行即可")]),t._v(" "),n("ul",[n("li",[t._v("用法：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n")])])]),n("blockquote",[n("p",[t._v("如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。")])]),t._v(" "),n("h5",{attrs:{id:"清除副作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#清除副作用"}},[t._v("#")]),t._v(" 清除副作用")]),t._v(" "),n("p",[t._v("有时候对于一些副作用，我们是需要去清除的，比如我们有个需求需要轮询向服务器请求最新状态，那么我们就需要在卸载的时候，清理掉轮询的操作。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  常规\n  componentDidMount() {\n    this.pollingNewStatus()\n  }\n\n  componentWillUnmount() {\n    this.unPollingNewStatus()\n  }\n\n  react hook\n  useEffect(() => {\n      pollingNewStatus()\n      //告诉React在每次渲染之前都先执行cleanup()\n      return function cleanup() {\n        unPollingNewStatus()\n      };\n    });\n\nuseEffect其实是每次渲染之前都会去执行cleanup(),而componentWillUnmount只会执行一次\n")])])]),n("h5",{attrs:{id:"effect性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#effect性能优化"}},[t._v("#")]),t._v(" Effect性能优化")]),t._v(" "),n("ul",[n("li",[t._v("useEffect其实是每次更新都会执行，在某些情况下会导致性能问题。那么我们可以通过跳过 Effect 进行性能优化。在class组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("componentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n}\n")])])]),n("ul",[n("li",[t._v("在Effect中，我们可以通过增加Effect的第二个参数即可，如果没有变化，则跳过更新")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 仅在 count 更改时更新\n\n")])])]),n("h2",{attrs:{id:"_3-antd-design-for-react"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-antd-design-for-react"}},[t._v("#")]),t._v(" 3. Antd design for React")]),t._v(" "),n("h4",{attrs:{id:"input同时"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#input同时"}},[t._v("#")]),t._v(" input同时")]),t._v(" "),n("h2",{attrs:{id:"_4-react-render执行流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-render执行流程"}},[t._v("#")]),t._v(" 4. react render执行流程")]),t._v(" "),n("p",[n("code",[t._v("https://www.jianshu.com/p/021736302706")])]),t._v(" "),n("h2",{attrs:{id:"_5-react-diffing算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-react-diffing算法"}},[t._v("#")]),t._v(" 5. React-diffing算法")]),t._v(" "),n("p",[n("code",[t._v("https://juejin.cn/post/6988446977541275661?from=main_page")])]),t._v(" "),n("ol",[n("li",[t._v("虚拟DOM->真是DOM，会通过diffing算法进行比较，如果已经渲染过一次再进行渲染，会对相同的key值节点进行比较，如果内容相同，会复用原来的真实DOM。")])]),t._v(" "),n("h2",{attrs:{id:"_6-父组件点击子组件执行"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-父组件点击子组件执行"}},[t._v("#")]),t._v(" 6. 父组件点击子组件执行")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, {Component} from 'react';\n\nexport default class Parent extends Component {\n    render() {\n        return(\n            <div>\n                <Child onRef={this.onRef} />\n                <button onClick={this.click} >click</button>\n            </div>\n        )\n    }\n\n    onRef = (ref) => {\n        this.child = ref\n    }\n\n    click = (e) => {\n        this.child.myName()\n    }\n\n}\n\nclass Child extends Component {\n    componentDidMount(){\n        this.props.onRef(this)\n    }\n\n    myName = () => alert('xiaohesong')\n\n    render() {\n        return ('woqu')\n    }\n}\n\n")])])]),n("h2",{attrs:{id:"_7-component和pureconponent区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-component和pureconponent区别"}},[t._v("#")]),t._v(" 7 Component和PureConponent区别")]),t._v(" "),n("p",[n("code",[t._v("https://juejin.cn/post/6943148190174707748")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate，当 prop 或 state 的值或者引用地址发生改变时，组件就会发生更新\nComponent 只要 state 发生改变， 不论值是否与之前的相等，都会触发更新\n")])])]),n("ol",[n("li",[t._v("Purecomponent通过props和state浅对比来实现shouldComponentUpdate()")])]),t._v(" "),n("blockquote",[n("p",[t._v("注意：在 PureComponent 中，当对传入的对象或者数组进行直接赋值时，因为并没有改变其引用地址，所以就不引起重新渲染。\n在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新\n每当shouldComponentUpdate被调用时，组件默认的会重新渲染。\n浅比较：将检查原始值是否有相同的值（例如：1 == 1或者ture==true）,数组和对象引用是否相同。")])]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("Component不会比较当前和下个状态的props和state。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);