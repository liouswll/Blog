(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{430:function(t,e,r){"use strict";r.r(e);var a=r(43),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"vue-router"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[t._v("#")]),t._v(" Vue-router")]),t._v(" "),r("p",[r("code",[t._v("https://juejin.im/post/6844903874533261325#heading-0")])]),t._v(" "),r("h3",{attrs:{id:"router和route-https-www-cnblogs-com-shaozhu520-p-11298805-html"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#router和route-https-www-cnblogs-com-shaozhu520-p-11298805-html"}},[t._v("#")]),t._v(" router和route  https://www.cnblogs.com/shaozhu520/p/11298805.html")]),t._v(" "),r("h3",{attrs:{id:"一-编程式导航"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一-编程式导航"}},[t._v("#")]),t._v(" 一 编程式导航")]),t._v(" "),r("blockquote",[r("p",[r("code",[t._v('<router-link :to="">')]),t._v("创建a标签来定义导航，还可借助router的实例方法。")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("声明式")]),t._v(" "),r("th",[t._v("编码式")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("code",[t._v('<router-link :to=".."')])]),t._v(" "),r("td",[r("code",[t._v("router.push(...)")])])])])]),t._v(" "),r("blockquote",[r("p",[t._v("使用router.push的方法，这个方法"),r("strong",[t._v("会向history栈中添加一个新的记录，当用户点击后退时，则回到之前的url")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如:\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({path: 'home'})\n\n// 命名的路由\nrouter.push({name: 'user', params: {userid: 123}})\n\n// 带参数查询，变成/register?plan=private\nrouter.push({path: 'user', query: { plan:'private'}})\n接受\nconst a = this.$route.query.plan\n\n")])])]),r("blockquote",[r("p",[t._v("提供的params，path会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const userId = '123'\nrouter.push({name: 'user', params: {userId}})  // ->  /user/123\nrouter.push({path: `/user/${userId}`}) // -> /user/123\n\n// params不生效  ×\nrouter.push({path: `/user`, params: {userId}})\n")])])]),r("blockquote",[r("p",[t._v("同样也适用于router-link组件的to属性")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("<router-link :to=\"{name: 'user', params: {userId: 123}}\">User</router-link>\n或者\nrouter.push({name: 'user', params: {userId: 123})\n")])])]),r("h3",{attrs:{id:"二-router-replace-location-oncomplete-onabort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-router-replace-location-oncomplete-onabort"}},[t._v("#")]),t._v(" 二 router.replace(location, onComplete?, onAbort?)")]),t._v(" "),r("ol",[r("li",[t._v("和router.push像，不同的是不会向history添加新纪录，而和它的方法名一样——替换掉当前history记录。")]),t._v(" "),r("li",[t._v("router.go(n)，参数为整数，意思在history记录中向前或者后退多少步。类似window.history.go(n)。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n\n")])])]),r("h2",{attrs:{id:"动态路由匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态路由匹配"}},[t._v("#")]),t._v(" 动态路由匹配")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const User = {\n    template: '<div>User</div>'\n}\n\nconst router = new VueRouter({\n    routers: [\n        // 动态路径参数 以冒号开头\n        {path: '/user/:id', conponent: User}\n    ]\n})\n")])])]),r("blockquote",[r("p",[t._v("/suer/foo和/user/bar都将映射到相同的路由，并用同一个模板渲染。可以利用"),r("strong",[t._v("this.$route.params.id")]),t._v("获取值。此处id是冒号后面的值，只要跟params后面的属性一样就能取到。")])]),t._v(" "),r("ol",[r("li",[t._v("你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 $route.params 中。例如：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("模式")]),t._v(" "),r("th",[t._v("匹配路径")]),t._v(" "),r("th",[t._v("this.$route.params")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("/user/:username")]),t._v(" "),r("td",[t._v("/user/evan")]),t._v(" "),r("td",[t._v("{username: 'evan'}")])]),t._v(" "),r("tr",[r("td",[t._v("/user/:username/post/:post_id")]),t._v(" "),r("td",[t._v("/user/evan/post/123")]),t._v(" "),r("td",[t._v("{username: 'evan', post_id: '123'}")])])])]),t._v(" "),r("blockquote",[r("p",[t._v("除了route.params外，route对象还提供了：route.query(如果url中有查询参数)，route.hash。")])]),t._v(" "),r("h2",{attrs:{id:"响应路由参数变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#响应路由参数变化"}},[t._v("#")]),t._v(" 响应路由参数变化")]),t._v(" "),r("p",[r("strong",[t._v("使用路由参数时，从/user/foo导航到/user/bar,原来的组件实例会被复用，"),r("strong",[t._v("两个路由都使用同个组件，比起销毁，复用则显得更加高效。不过也意味着")]),t._v("组件生命周期钩子不会被点用")])]),t._v(" "),r("ol",[r("li",[t._v("复用组件时，相对路由参数做出响应的话，可以简单的watch（监测变化）$route对象：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const user = {\n    template: '...',\n    watch: {\n        '$route'(to, from){\n            // 对路由做出响应\n        }\n    }\n}\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("使用2.2中的beforeRouteUpdate导航守卫：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const User = {\n    template: '...',\n    beforeRouteUpdate(to, from, next){\n        // react to route changes\n        // do not forget to call next()\n    }\n}\n")])])]),r("h2",{attrs:{id:"捕获所有路由和404-not-foundluyu路由。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#捕获所有路由和404-not-foundluyu路由。"}},[t._v("#")]),t._v(" 捕获所有路由和404 Not Foundluyu路由。")]),t._v(" "),r("ol",[r("li",[t._v("常规参数只会被/分割的url片段中的字符。如果想匹配任意路径，可以使用通佩符(*)")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("{\n    // 会匹配所有路径\n    path: '*'\n}\n{\n    // 匹配所有以`/user-`开头的路径\n    path: '/user-*'\n}\n")])])]),r("blockquote",[r("p",[t._v("当使用通配符路由时，请确保路由的顺序是正确的，"),r("em",[t._v("含通配符的路由应该放到最后面。路由{path: '")]),t._v("'}常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。")])]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch参数。它包含了URL通过通配符被匹配的部分：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// 给出一个路由：{path: '/user-*'}\nthis.$router.push('/user-admin')\nthis.$route.params.pathMatch   // 'admin'\n\n// 给出一个理由\nthis.$router.push('/non-existing')\nthis.$route.params.pathMatch // '/non-existing'\n")])])]),r("h2",{attrs:{id:"嵌套路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#嵌套路由"}},[t._v("#")]),t._v(" 嵌套路由")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n    routers: [\n        {path: '/user/:id', component: User,\n            children: [\n                {\n                    //   当/user/:id/profile匹配成功，\n                    //   UserProfile 会被渲染在User的<router-view>中\n\n                    path: 'profile',\n                    component: UserProfile\n                },\n                {\n                    //   当/user/:id/posts匹配成功，\n                    //   UserPosts会被渲染在User的<router-view>中\n\n                    path: 'posts',\n                    component: UserPosts\n                }\n            ]\n        }\n    ]\n})\n")])])]),r("p",[t._v("基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个空的子路由：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:id', component: User,\n      children: [\n            //    当 /user/:id 匹配成功，\n            //    UserHome 会被渲染在 User 的 <router-view> 中\n            {   \n                path: '', \n                component: UserHome\n            },\n\n            // ...其他子路由\n       ]\n    }\n  ]\n})\n")])])]),r("h2",{attrs:{id:"命名路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命名路由"}},[t._v("#")]),t._v(" 命名路由")]),t._v(" "),r("ol",[r("li",[t._v("通过命名标识一个路由，创建Router实例的时候，在routes配置中设置名称。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n    routes: [\n        {\n            path: '/user/:userId',\n            name: 'user',\n            compoent: User\n        }\n    ]\n})\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("要链接到一个命名路由，可以给router-link的to属性传一个对象：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('<router-link :to="{name: \'user\', params: "{userId: 123}"}">user</router-link>\n')])])]),r("ol",{attrs:{start:"3"}},[r("li",[t._v("和调用router.push()情况差不多")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("router.push({name: 'suer', params: { userId: 123 }})\n")])])]),r("p",[t._v("两种方式都可以导向/user/123路径")]),t._v(" "),r("h2",{attrs:{id:"重定向和别名"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重定向和别名"}},[t._v("#")]),t._v(" 重定向和别名")]),t._v(" "),r("ol",[r("li",[t._v("重定向通过routes配置，下面从/a重定向到/b")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n    routes: [\n        {\n            path: '/a',\n            redirect: '/b'\n        }\n    ]\n})\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("重定向的目标也可以是个命名路由")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: { name: 'foo' }}\n  ]\n})\n")])])]),r("ol",{attrs:{start:"3"}},[r("li",[t._v("甚至是一个方法，动态返回重定向目标：")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n")])])]),r("blockquote",[r("p",[t._v("注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。")])]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("别名\n/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', component: A, alias: '/b' }\n  ]\n})\n")])])]),r("h2",{attrs:{id:"路由组件传参"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由组件传参"}},[t._v("#")]),t._v(" 路由组件传参")]),t._v(" "),r("p",[t._v("在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 props 将组件和路由解耦")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const User = {\n   props: [id],\n   template: '<div>UserId: {{id}}</div>'\n}\n\nconst router = new VueRouter({\n    routes: [\n        {\n            path: '/user/:id',\n            component: User,\n            props: true\n        },\n        // 对于包含命名视图的路由，必须为每个命名视图添加props选项\n        {\n            path: '/user/:id',\n            components: { default: User, sidebar: Sidebar },\n            props: { default: true, sidebar: false }\n        }\n    ]\n})\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);