(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{391:function(t,e,a){t.exports=a.p+"assets/img/redux.89734f45.png"},432:function(t,e,a){"use strict";a.r(e);var r=a(43),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"redux"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),r("h4",{attrs:{id:"javascript状态容器，提供可预测化的状态管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript状态容器，提供可预测化的状态管理"}},[t._v("#")]),t._v(" JavaScript状态容器，提供可预测化的状态管理")]),t._v(" "),r("p",[t._v("web应用是一个状态机，视图与状态是一一对应的所有的状态都保存在一个对象里面")]),t._v(" "),r("h2",{attrs:{id:"基本用法-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本用法-api"}},[t._v("#")]),t._v(" 基本用法 API")]),t._v(" "),r("ol",[r("li",[t._v("store（容器）保存数据的地方，利用createStore生成store")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { createStore } from 'redux'\nconst store = createStore(fn)\n接受另一个函数作为参数，返回新生成的store对象\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("state组件内部的状态，store包含的所有对象，得到数据store.getState()")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { createStore } from 'redux';\nconst store = createStore(fn);\n\nconst state = store.getState();\n一个state只对应一个view\n")])])]),r("ol",{attrs:{start:"3"}},[r("li",[t._v("action组件动作，相应的改变组件内部的状态值（ View 发出的通知，表示 State 应该要发生变化了）")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("\tstate的变化会导致view的变化，state的变化必须是view导致\n\tAction 就是 View 发出的通知，表示 State 应该要发生变化了。\n\tconst action = {\n  \t\ttype: 'ADD_TODO',\n  \t\tpayload: 'Learn Redux'\n\t};\n\tActioc会运送数据到 Store\n\n\n    view发送多少信息，就会有多少的action，定义一个action函数 。此时就是action creator\n\tconst ADD_TODO = '添加 TODO';\n\tfunction addTodo(text) {\n  \treturn {\n    \ttype: ADD_TODO,\n    \ttext\n  \t\t}\n\t}\n\tconst action = addTodo('Learn Redux');\n")])])]),r("ol",{attrs:{start:"4"}},[r("li",[t._v("dispatch发出相应的动作，store.dispatch( )，是view发出action的唯一方法")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { createStore } from 'redux';\nconst store = createStore(fn);\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n});\n")])])]),r("ol",{attrs:{start:"5"}},[r("li",[t._v("Reducer是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const reducer = function (state, action) {\n  // ...\n  return new_state;\n}\n\n\n\nstore收到Action的时候，必须给出一个新的state，这样view才会变化。这种 State 的计算过程就叫做 Reducer。\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2\n});\n")])])]),r("ol",{attrs:{start:"6"}},[r("li",[t._v("store.subscribe() 设置监听方法，一旦state发生变化，就会自动执行这个函数要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { createStore } from 'redux';\nconst store = createStore(reducer);\nstore.subscribe(listener);\n\nfunction listerner() {\n  let newState = store.getState();\n  component.setState(newState);   \n}\n")])])]),r("ol",{attrs:{start:"7"}},[r("li",[t._v("store.subscribe方法返回一个函数，调用这个函数就可以解除监听。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let unsubscribe = store.subscribe(() =>\n  console.log(store.getState())\n);\n\nunsubscribe();\n")])])]),r("h2",{attrs:{id:"基本用法-流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本用法-流程"}},[t._v("#")]),t._v(" 基本用法 流程")]),t._v(" "),r("p",[t._v("图示"),r("br"),t._v(" "),r("img",{attrs:{src:a(391),alt:"redux"}}),r("br"),t._v(" "),r("code",[t._v("store")]),t._v(" ➡️ "),r("code",[t._v("dispatch")]),t._v(" ➡️ "),r("code",[t._v("action")]),t._v(" ⬅️ "),r("code",[t._v("reducer")])]),t._v(" "),r("p",[t._v("文字描述")]),t._v(" "),r("ol",[r("li",[t._v("用户发出 Action。   "),r("code",[t._v("store.dispatch(action);")])]),t._v(" "),r("li",[t._v("Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State,"),r("code",[t._v("let nextState = todoApp(previousState, action);")])]),t._v(" "),r("li",[t._v("State 一旦有变化，Store 就会调用监听函数\n"),r("code",[t._v("// 设置监听函数 store.subscribe(listener);")])]),t._v(" "),r("li",[t._v("istener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。\nfunction listerner() {\nlet newState = store.getState();\ncomponent.setState(newState);"),r("br"),t._v("\n}")])]),t._v(" "),r("p",[t._v("注意点")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法\n\n// State 是一个对象\nfunction reducer(state, action) {\n  return Object.assign({}, state, { thingToChange });\n  // 或者\n  return { ...state, ...newState };\n}\n\n// State 是一个数组\nfunction reducer(state, action) {\n  return [...state, newItem];\n}\n")])])]),r("h2",{attrs:{id:"中间与异步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中间与异步"}},[t._v("#")]),t._v(" 中间与异步")]),t._v(" "),r("h4",{attrs:{id:"中间件是一个函数，对store-dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中间件是一个函数，对store-dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能"}},[t._v("#")]),t._v(" 中间件是一个函数，对store.dispatch方法进行了改造，在发生action和执行reducer之间，添加了其他功能")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let next = store.dispatch;\nstore.dispatch = function dispatchAndLog(action) {\n  console.log('dispatching', action);\n  next(action);\n  console.log('next state', store.getState());\n}\n")])])]),r("h4",{attrs:{id:"中间件的用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中间件的用法"}},[t._v("#")]),t._v(" 中间件的用法")]),t._v(" "),r("ul",[r("li",[t._v("ctreate可以接受整个应用的初试状态作为参数")]),t._v(" "),r("li",[t._v("中间件讲究有次序")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { applyMiddleware, createStore } from 'redux';\nimport createLogger from 'redux-logger';\nconst logger = createLogger();\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n);\n")])])]),r("ul",[r("li",[t._v("applyMiddleware（）方法，redux的原生方法，将所有的中间件组成一个数组。依次执行所有的中间件，全部被放进一个chaid数组中，然后嵌套执行，最后执行store.dispatch")])]),t._v(" "),r("h4",{attrs:{id:"异步操作的思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的思路"}},[t._v("#")]),t._v(" 异步操作的思路")]),t._v(" "),r("ol",[r("li",[t._v("同步操作只要发出一种action，异步操作的差别是它要发出三种action")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("操作发起的action\n操作成功时的action\n操作失败时的action\n// 写法一：名称相同，参数不同\n{ type: 'FETCH_POSTS' }\n{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }\n{ type: 'FETCH_POSTS', status: 'success', response: { ... } }\n\n// 写法二：名称不同\n{ type: 'FETCH_POSTS_REQUEST' }\n{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }\n{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }\n\t\t\t\tstate\n\t\t\t\t\tlet state = {\n // ... \nisFetching: true,\ndidInvalidate: true,\nlastUpdated: 'xxxxxxx'\n};\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。")]),t._v(" "),r("li",[t._v('操作开始时，送出一个 Action，触发 State 更新为"正在操作"状态，View 重新渲染\n操作结束后，再送出一个 Action，触发 State 更新为"操作结束"状态，View 再一次重新渲染')])]),t._v(" "),r("h4",{attrs:{id:"异步操作的解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的解决方案"}},[t._v("#")]),t._v(" 异步操作的解决方案")]),t._v(" "),r("ol",[r("li",[t._v("redux-thunk\n"),r("ul",[r("li",[t._v("Action Creator返回函数，然后使用redux-thunk中间件改造store.dispatch")]),t._v(" "),r("li",[t._v("使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。")])])]),t._v(" "),r("li",[t._v("redu-propmise这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数\n"),r("ul",[r("li",[t._v("Action Creator 返回一个 Promise 对象，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)），但 reject 以后不会有任何动作")]),t._v(" "),r("li",[t._v("Action 对象的payload属性是一个 Promise 对象。需要从redux-actions模块引入createAction方法。如果 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。")])])])]),t._v(" "),r("h2",{attrs:{id:"react-redux用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-redux用法"}},[t._v("#")]),t._v(" react-redux用法")]),t._v(" "),r("h4",{attrs:{id:"注意点：一个组件既有ui又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个ui-组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注意点：一个组件既有ui又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个ui-组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图"}},[t._v("#")]),t._v(" 注意点：一个组件既有UI又有业务逻辑。将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图")]),t._v(" "),r("h4",{attrs:{id:"ui组件（纯组件）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ui组件（纯组件）"}},[t._v("#")]),t._v(" UI组件（纯组件）")]),t._v(" "),r("p",[t._v("只负责 UI 的呈现，不带有任何业务逻辑"),r("br"),t._v("\n没有状态（即不使用this.state这个变量）"),r("br"),t._v("\n所有数据都由参数（this.props）提供"),r("br"),t._v("\n不使用任何 Redux 的 API")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("\tconst Title =value => <h1>{value}</h1>;\n")])])]),r("h4",{attrs:{id:"容器组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器组件"}},[t._v("#")]),t._v(" 容器组件")]),t._v(" "),r("ol",[r("li",[t._v("负责管理数据和业务逻辑，不负责 UI 的呈现带有内部状态使用 Redux 的 API")])]),t._v(" "),r("h4",{attrs:{id:"connect-连接ui，容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#connect-连接ui，容器"}},[t._v("#")]),t._v(" connect()  连接UI，容器")]),t._v(" "),r("p",[t._v("（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数")]),t._v(" "),r("p",[t._v("（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。"),r("code",[t._v("import { connect } from 'react-redux'")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const VisibleTodoList = connect(\n  mapStateToProps,（前者负责输入逻辑，即将state映射到 UI 组件的参数（props））\n  mapDispatchToProps（者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action）\n)(TodoList)\n")])])]),r("h4",{attrs:{id:"mapstatetoprops-建立一个从（外部的）state对象到（ui-组件的）props对象的映射关系。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mapstatetoprops-建立一个从（外部的）state对象到（ui-组件的）props对象的映射关系。"}},[t._v("#")]),t._v(" mapStateToProps() 建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。")]),t._v(" "),r("ol",[r("li",[t._v("mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const mapStateToProps = (state) => {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const getVisibleTodos = (todos, filter) => {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t => t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t => !t.completed)\n    default:\n      throw new Error('Unknown filter: ' + filter)\n  }\n}\n")])])]),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[t._v("mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。")])]),t._v(" "),r("li",[r("p",[t._v("connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const mapStateToProps = (state, ownProps) => {\n  return {\n    active: ownProps.filter === state.visibilityFilter\n  }\n}\n")])])]),r("h4",{attrs:{id:"mapdispatchtoprops"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mapdispatchtoprops"}},[t._v("#")]),t._v(" mapDispatchToProps()")]),t._v(" "),r("p",[t._v("建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。")]),t._v(" "),r("ol",[r("li",[t._v("函数"),r("br"),t._v("\ndispatch和ownProps（容器组件的props对象）两个参数mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'SET_VISIBILITY_FILTER',\n        filter: ownProps.filter\n      });\n    }\n  };\n}\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("对象"),r("br"),t._v("\n键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const mapDispatchToProps = {\n  onClick: (filter) => {\n    type: 'SET_VISIBILITY_FILTER',\n    filter: filter\n  };\n}\n")])])]),r("h4",{attrs:{id:"provider"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#provider"}},[t._v("#")]),t._v(" Provider")]),t._v(" "),r("p",[t._v("connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。")]),t._v(" "),r("p",[t._v("一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。")]),t._v(" "),r("p",[t._v("React-Redux 提供Provider组件，可以让容器组件拿到state")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp);\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\ndocument.getElementById('root') \n")])])]),r("h2",{attrs:{id:"react-router"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" react-router")]),t._v(" "),r("ul",[r("li",[t._v("使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('const Root = ({ store }) => (\n  <Provider store={store}>\n    <Router>\n      <Route path="/" component={App} />\n    </Router>\n  </Provider>\n);\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);