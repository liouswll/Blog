(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{449:function(t,e,a){"use strict";a.r(e);var n=a(43),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook"}},[t._v("#")]),t._v(" Hook")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("React Hooks要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享")])]),t._v(" "),a("li",[a("p",[t._v("React Hook")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { useState } from 'React';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n")])])]),a("ul",[a("li",[t._v("React State")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n\n")])])]),a("p",[a("strong",[t._v("在React Hook中，class Example组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都得益于useState这个Hook，useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并")])]),t._v(" "),a("h2",{attrs:{id:"react-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[t._v("#")]),t._v(" React Hook")]),t._v(" "),a("ul",[a("li",[t._v("动机：在组件之间复用状态逻辑很难，复杂组件变得难以理解，难以理解的 class。")]),t._v(" "),a("li",[t._v("语法：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import React, { useState } from 'React';\nconst [count, setCount] = useState(0);\n\n等价于\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n  };\n}\n")])])]),a("ul",[a("li",[a("p",[t._v("useState参数"),a("br"),t._v("\n传入了0作为useState的参数，这个参数的数值会被当成count初始值。当然此参数"),a("strong",[t._v("不限于传递数字以及字符串，可以传入一个对象当成初始的state")]),t._v("。如果state需要储存多个变量的值，那么调用多次useState即可")])]),t._v(" "),a("li",[a("p",[t._v("useState返回值"),a("br"),t._v("\n返回值为：当前 state 以及更新 state 的函数，这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。看到[count, setCount]很容易就能明白这是ES6的解构数组的写法。相当于以下代码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let _useState = useState(0);// 返回一个有两个元素的数组\nlet count = _useState[0];// 数组里的第一个值\nlet setCount = _useState[1];// 数组里的第二个值\n")])])])]),t._v(" "),a("li",[a("p",[t._v("读取状态值"),a("br"),t._v("\n以前"),a("code",[t._v("<p>You clicked {this.state.count} times</p>")]),a("br"),t._v("\n现在"),a("code",[t._v("<p>You clicked {count} times</p>")])])]),t._v(" "),a("li",[a("p",[t._v("更新状态")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("以前\n<button onClick={() => this.setState({ count: this.state.count + 1 })}>\n    Click me\n </button>\n\n现在\n<button onClick={() => setCount(count + 1)}>\n    Click me\n</button>\n\n")])])]),a("h4",{attrs:{id:"声明多个state变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明多个state变量"}},[t._v("#")]),t._v(" 声明多个state变量")]),t._v(" "),a("ul",[a("li",[t._v("一个组件中多次使用state hook")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function ExampleWithManyStates() {\n  // 声明多个 state 变量！\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n  // ...\n}\n")])])]),a("p",[t._v("React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的")]),t._v(" "),a("h4",{attrs:{id:"hook-规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook-规则"}},[t._v("#")]),t._v(" Hook 规则")]),t._v(" "),a("ol",[a("li",[t._v("只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。")]),t._v(" "),a("li",[t._v("只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook。")])]),t._v(" "),a("blockquote",[a("p",[t._v("这两条规则出现的原因是，我们可以在单个组件中使用多个State Hook 或 Effect Hook，React 靠的是 Hook 调用的顺序来知道哪个 state 对应哪个useStat")])]),t._v(" "),a("h4",{attrs:{id:"effect-hook使用-effect在组件渲染后执行即可"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#effect-hook使用-effect在组件渲染后执行即可"}},[t._v("#")]),t._v(" Effect Hook使用 -> Effect在组件渲染后执行即可")]),t._v(" "),a("ul",[a("li",[t._v("用法：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n")])])]),a("blockquote",[a("p",[t._v("如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。")])]),t._v(" "),a("h4",{attrs:{id:"清除副作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#清除副作用"}},[t._v("#")]),t._v(" 清除副作用")]),t._v(" "),a("p",[t._v("有时候对于一些副作用，我们是需要去清除的，比如我们有个需求需要轮询向服务器请求最新状态，那么我们就需要在卸载的时候，清理掉轮询的操作。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  常规\n  componentDidMount() {\n    this.pollingNewStatus()\n  }\n\n  componentWillUnmount() {\n    this.unPollingNewStatus()\n  }\n\n  react hook\n  useEffect(() => {\n      pollingNewStatus()\n      //告诉React在每次渲染之前都先执行cleanup()\n      return function cleanup() {\n        unPollingNewStatus()\n      };\n    });\n\nuseEffect其实是每次渲染之前都会去执行cleanup(),而componentWillUnmount只会执行一次\n")])])]),a("h4",{attrs:{id:"effect性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#effect性能优化"}},[t._v("#")]),t._v(" Effect性能优化")]),t._v(" "),a("ul",[a("li",[t._v("useEffect其实是每次更新都会执行，在某些情况下会导致性能问题。那么我们可以通过跳过 Effect 进行性能优化。在class组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n}\n")])])]),a("ul",[a("li",[t._v("在Effect中，我们可以通过增加Effect的第二个参数即可，如果没有变化，则跳过更新")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 仅在 count 更改时更新\n\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);