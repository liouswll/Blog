(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{392:function(e,t,n){e.exports=n.p+"assets/img/vue-Observer.b6ca3db2.png"},428:function(e,t,n){"use strict";n.r(t);var a=n(43),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"_1-vue2-x到vue3-x"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue2-x到vue3-x"}},[e._v("#")]),e._v(" 1. vue2.x到vue3.x")]),e._v(" "),a("h4",{attrs:{id:"双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[e._v("#")]),e._v(" 双向绑定")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[e._v("vue2.x")]),e._v(" 通过Object.defineproperty重定义data中的属性get和set方法，从而劫持data中的set和get操作。存在问题：")]),e._v(" "),a("ol",[a("li",[e._v("实例创建后添加的属性监听不到，数据劫持是在数据初始化的过程中执行。具体在beforeCreate和Create生命周期内完成，可以通过$set解决后续天骄监听属性的问题。")]),e._v(" "),a("li",[e._v("defineProperty()无法监听数组的变化，当直接用index设置数组项是不会被检测出来的，如："),a("code",[e._v("this.showData[1] = {a:1}")]),e._v("。当然也能用$set解决。通过下面八种方法操作数组，Vue能检测到数据变化，分别为：push()、pop()、shift()、unshift()、splice()、sort()、reverse()")])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("vue3.x")]),e._v(" 采用Proxy和Reflect实现双向绑定，它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。我们可以这样认为，Proxy是Object.defineProperty的全方位加强版。")]),e._v(" "),a("ol",[a("li",[e._v("Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。Object.defineProperty不能做的Proxy还能做。")]),e._v(" "),a("li",[e._v("Proxy作为新标准，得到了各大浏览器厂商的大力支持，性能持续优化。唯一的不足就是兼容性的问题，而且无法通过polyfill解决。")])])])]),e._v(" "),a("h2",{attrs:{id:"_2-vue3-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue3-proxy"}},[e._v("#")]),e._v(" 2. vue3 Proxy")]),e._v(" "),a("ul",[a("li",[e._v("理解为在对象之前设置一个“拦截”，当该对象被访问的时候，都必须经过这层拦截。意味着你可以在这层拦截中进行各种操作。比如你可以在这层拦截中对原对象进行处理，返回你想返回的数据结构。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("- 基础\nconst p = new Proxy(target, handler);\ntarget： 所要拦截的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）\nhandler：一个对象，定义要拦截的行为\nconst p = new Proxy({}, {\n    get(target, propKey) {\n        return '哈哈，你被我拦截了';\n    }\n});\nconsole.log(p.name);\n// 哈哈，你被我拦截了\n\n\n- Proxy是用来操作对象的。代理的目的是为了拓展对象的能力。\nconst p = new Proxy({}, {\n    set(target, propKey, value) {\n        if (propKey === 'name') {\n            throw new TypeError('name属性不允许修改');\n        }\n        // 不是 name 属性，直接保存\n        target[propKey] = value;\n    }\n});\np.name = 'proxy';\n// TypeError: name属性不允许修改\np.a = 111;\nconsole.log(p.a); // 111\n")])])]),a("h2",{attrs:{id:"_3-vue3-vue-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue3-vue-set"}},[e._v("#")]),e._v(" 3. vue3 Vue.set")]),e._v(" "),a("ul",[a("li",[e._v("Vue.set( target, key, value )"),a("br"),e._v("\ntarget：要更改的数据源(可以是对象或者数组)"),a("br"),e._v("\nkey：要更改的具体数据"),a("br"),e._v("\nvalue ：重新赋的值")])]),e._v(" "),a("h2",{attrs:{id:"_4-vue3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue3"}},[e._v("#")]),e._v(" 4. vue3")]),e._v(" "),a("ul",[a("li",[e._v("示例 参考资料https://juejin.im/post/5e13ecbe6fb9a04846508ab2")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<body>\n    <div id="app"></div>\n</body>\n<script src="./index.js"><\/script>\n\n\nconst { reactive } = Vue\nvar App = {\n  template: `\n    <div class="container">\n         {{message}}\n    </div>`,\n  setup() {\n  \tconst state = reactive({message: "Hello World!!!"})\n\treturn {\n\t\t...state\n\t}\n  }\n}\nVue.createApp().mount(App, \'#app\')\n\n')])])]),a("ul",[a("li",[e._v("OptionApi => Composition API"),a("br"),e._v("\nsetup, reactive等函数")]),e._v(" "),a("li",[e._v("setup"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const { reactive } = Vue\nlet App = {\ntemplate: `\n    <div class="container">\n        <input v-model="state.value"/>{{state.value}}\n    </div>`,\nsetup() {\n    const state = reactive({ value: \'\' })\n    return { state }\n}\n}\nVue.createApp().mount(App, \'#app\')\n\n setup实际上是一个组件的入口，它运行在组件被实例化时候，props 属性被定义之后，实际上等价于 2 版本的beforeCreate 和 Created 这两个生命周期。\n\n setup接受两个参数，第一个参数是props， 另一个参数是context，所以大家在使用2.0时习惯的在this下获取属性的方式 ，在 vue3.0 中，变成了：\n setup(props, ctx) {\n    console.log(props, ctx)\n}\n\n- 传值\nlet Child = {\n    template: `<div>{{title}}</div>`,\n    setup(props, context) {\n        console.log(props)\n    }\n}\nlet App = {\n    template: `\n        <div class="container">\n            <Child title="test props"/>\n        </div>`,\n    components: { Child }\n}\nVue.createApp().mount(App, \'#app\')\n\n\n')])])])]),e._v(" "),a("li",[e._v("reactive"),a("br"),e._v("\n在Vue3中，我们可以把数据经过 reactive 加工变成响应式的对象，用于模版的渲染数据， 当然Vue的向下兼容 还是允许我们使用data的方式实现"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const { reactive, toRefs } = Vue\nlet App = {\ntemplate: `\n    <div class="container">\n        count: {{count}}\n        <button @click="handlerCountAdd"> Click ++ </button>\n    </div>`,\n    setup() {\n        const state = reactive({ count: 0 })\n        const handlerCountAdd = () => {\n            state.count++\n        }\n        return { ...toRefs(state), handlerCountAdd }\n    }\n}\nVue.createApp().mount(App, \'#app\')\n')])])])]),e._v(" "),a("li",[e._v("toRefs")])]),e._v(" "),a("ol",[a("li",[e._v("先说下 ref ，vue3提供的ref让我们有机会创建单个的响应式的对象，在setup函数中return出去之后，在模板中可直接访问"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const App = {\ntemplate: `\n    <div class=\"container\">\n        {{value}}     \n    </div>`,\nsetup() {\n    const value = ref(1)\n    return { value }\n}\n}\nVue.createApp().mount(App, '#app')\n")])])])]),e._v(" "),a("li",[e._v("那上文提到的 reactive创建的响应式对象 在模板中访问的话，则需要state.xxx。，vue3提供的toRefs正是为我们解决这个问题的，toRefs把一组的响应式对象拆成单个的响应式对象，就能够在模板中直接访问了。"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const App = {\ntemplate: `\n    <div class=\"container\">\n        {{value}}\n        // {{state.value}} 不使用toRefs\n    </div>`,\nsetup() {\n    const state = reactive({ value: 'reactive' })\n    return toRefs(state)\n}\n}\nVue.createApp().mount(App, '#app')\n")])])])])]),e._v(" "),a("ul",[a("li",[e._v("computed 计算属性")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("反转字符串 demo\nlet App = {\n  template: `\n    <div class=\"container\">\n        value: <input v-model=\"value\"/>\n        <br/>\n        rvalue: {{rvalue}}\n    </div>`,\n  setup() {\n    const state = reactive({\n      value: '',\n      rvalue: computed(() =>\n        state.value\n          .split('')\n          .reverse()\n          .join('')\n      )\n    })\n    return toRefs(state)\n  }\n}\nVue.createApp().mount(App, '#app')\n\n")])])]),a("ul",[a("li",[e._v("数据响应式 effect和watch\neffect和watch都可以监听到咱们数据的变化"),a("br"),e._v("\neffect 在响应式数据变化的时候就会执行，执行次数根据响应式数据的个数来决定"),a("br"),e._v("\nwatch则点击一次 ，只会触发执行一次")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let App = {\n  template: `\n    <div class=\"container\">\n        <button @click=\"handlerCountAdd\"> Click ++ </button>\n    </div>`,\n  setup() {\n    const state = reactive({ count: 0, value: 1 })\n    const r = ref(1)\n    const s = ref(1)\n    const t = ref(1)\n    const handlerCountAdd = () => {\n      r.value *= 1\n      s.value *= 2\n      t.value *= 3\n    }\n    watch([r, s, t], val => {\n      console.log('watch', val)\n    })\n    //effect(() => {\n    //  console.log('effect', [r.value, s.value, t.value])\n    //})\n    return { handlerCountAdd }\n  }\n}\nVue.createApp().mount(App, '#app')\n\n")])])]),a("h2",{attrs:{id:"_5-vue中的ref-refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue中的ref-refs"}},[e._v("#")]),e._v(" 5. Vue中的ref $refs")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("ref 被用来给元素或者子组件注册引用信息。引用信息将会注册在父组件的$refs上对象上。"),a("br"),e._v("\n普通的DOM元素上，那就指向DOM元素。子组件上，指向组件实例。")])]),e._v(" "),a("li",[a("p",[e._v("$refs 一个对象，持有已注册过ref的所有子组件。")])])]),e._v(" "),a("h2",{attrs:{id:"_6-vue异步dom更新（含ref）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue异步dom更新（含ref）"}},[e._v("#")]),e._v(" 6. Vue异步DOM更新（含ref）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('(ref $refs示例)\n<template>\n  <div id="app">\n    <ul ref="ul">\n      <li v-for="(item, index) in arr" :key="index">{{item}}</li>\n    </ul>\n    <button @click="add">add</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      arr: [1, 2, 3, 4],\n    };\n  },\n  methods: {\n    add() {\n      this.arr.push(Math.random());\n      this.arr.push(Math.random());\n      this.arr.push(Math.random());\n      console.log(this.arr);\n      console.log(this.$refs.ul.childNodes.length);\n    },\n  },\n};\n<\/script>\n\n//  7 4\n//  10 7\n即使打印添加在后面，数据已经放进arr中，但是vue没有把新增的渲染进来，此时的DOM还是原来的li节点。\n同步渲染的那种效果。我们就是希望能够及时拿到先要的数据该怎么做呢（nextTick基本使用）\n')])])]),a("h2",{attrs:{id:"_7-nexttick基本使用（及时取到先要数据）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-nexttick基本使用（及时取到先要数据）"}},[e._v("#")]),e._v(" 7. nextTick基本使用（及时取到先要数据）")]),e._v(" "),a("ol",[a("li",[e._v("vue的全局还有实例中提供了nextTickAPI，用法：首先接受一个回调函数，即这个回调会在"),a("strong",[e._v("DOM更新后执行")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("add() {\n      this.arr.push(Math.random());\n      this.arr.push(Math.random());\n      this.arr.push(Math.random());\n      console.log(this.arr);\n\n      this.$nextTick(() => {\n        console.log(this.$refs.ul.childNodes.length);\n      });\n\n    },\n// 7 7 \n// 10 10\n")])])]),a("h2",{attrs:{id:"_8-插槽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-插槽"}},[e._v("#")]),e._v(" 8. 插槽")]),e._v(" "),a("p",[e._v("https://juejin.im/post/6864570298767769607#heading-10")]),e._v(" "),a("h2",{attrs:{id:"_9-动态组件和异步组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-动态组件和异步组件"}},[e._v("#")]),e._v(" 9. 动态组件和异步组件")]),e._v(" "),a("ol",[a("li",[e._v("component元素绑定一个is属性实现。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<template>\n  <div id="app">\n    <ul @click="change">\n      <li>test01</li>\n      <li>test02</li>\n      <li>test03</li>\n    </ul>\n\n    <div class="zhan"></div>\n\n    <component :is="componentId"></component>\n  </div>\n</template>\n<script>\nimport Test01 from "./components/test01";\nimport Test02 from "./components/test02";\nimport Test03 from "./components/test03";\nexport default {\n  data() {\n    return {\n      componentId: "Test01",\n    };\n  },\n  methods: {\n    change(e) {\n      this.componentId = e.target.innerText;\n    },\n  },\n  components: {\n    Test01,\n    Test02,\n    Test03,\n  },\n};\n<\/script>\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("异步加载组件")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  components: {\n    Test01:()=>import('./components/test01'),//返回的是promise\n    Test02:()=>import('./components/test02'),\n    Test03:()=>import('./components/test03'),\n  },\n")])])]),a("h2",{attrs:{id:"_10-keep-alive是vue一个内置组件（主要就是要实现组件缓存）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-keep-alive是vue一个内置组件（主要就是要实现组件缓存）"}},[e._v("#")]),e._v(" 10.keep-alive是vue一个内置组件（主要就是要实现组件缓存）")]),e._v(" "),a("ol",[a("li",[e._v("keep-alive缓存，用"),a("code",[e._v("<keep-alive>")]),e._v("标签将动态目标包裹。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(' <keep-alive>\n      <component :is="componentId"></component>\n    </keep-alive>\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("有三个属性")])]),e._v(" "),a("ul",[a("li",[e._v("include 字符串或者正则表达式。只有名称匹配的组件"),a("strong",[e._v("会被缓存。")])]),e._v(" "),a("li",[e._v("exclude 字符串或者正则表达式。名称匹配的组件"),a("strong",[e._v("不会被缓存。")])]),e._v(" "),a("li",[e._v("max 数字。最多可以缓存多少组件实例。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('\x3c!-- 逗号分隔字符串 --\x3e\n<keep-alive include="a,b">\n  <component :is="view"></component>\n</keep-alive>\n\n\x3c!-- 正则表达式 (使用 `v-bind`) --\x3e\n<keep-alive :include="/a|b/">\n  <component :is="view"></component>\n</keep-alive>\n\n\x3c!-- 数组 (使用 `v-bind`) --\x3e\n<keep-alive :include="[\'a\', \'b\']">\n  <component :is="view"></component>\n</keep-alive>\n匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。\n')])])]),a("ol",{attrs:{start:"3"}},[a("li")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("我们最终的目的就是储存组件，那么我们就要考虑使用什么数据结构保存、在什么时候创建这个创建结构、传过来的三个属性值变化了我们在哪个钩子里做处理、keep-alive组件销毁之后，所有存储的组件也要进行销毁\n  1. create钩子创建储存数据结构。  \n  2. mounted钩子执行完就完成挂载，钩子在额更新钩子后面，再次触发，可以拿到新传过来的三个属性的值。\n  3. mounted () {\n      this.$watch('include', val => {\n          pruneCache(this, name => matches(val, name))\n      })\n      this.$watch('exclude', val => {\n          pruneCache(this, name => !matches(val, name))\n      })\n  }\n  pruneCache这个函数，就是把以储存的组件，根据include或exclude的最新变化进行判断是否还需要储存，不需要剔除缓存对象中\n  4. destory 把缓存中所有组件都销毁。\n")])])]),a("h2",{attrs:{id:"_11-混入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-混入"}},[e._v("#")]),e._v(" 11. 混入")]),e._v(" "),a("ol",[a("li",[e._v("混入提供了一种非常灵活的方式，来分发vue组件中可复用功能。一个混入的对象可以包含任意组件的对象。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<template>\n  <div>test01</div>\n</template>\n<script>\nconst mixin = {\n  created() {\n    console.log('混进来的')\n  },\n};\nexport default {\n  mixins: [mixin],\n \n  created() {\n    console.log('组件上的')\n  },\n};\n<\/script>\n\n")])])]),a("h2",{attrs:{id:"_12-onref-子组件向父组件传递数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-onref-子组件向父组件传递数据"}},[e._v("#")]),e._v(" 12. onRef 子组件向父组件传递数据")]),e._v(" "),a("p",[a("code",[e._v("https://www.jianshu.com/p/c3e31d62bf76")])]),e._v(" "),a("ol",[a("li",[e._v("父组件：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<InsureCustomerInfo\n    dataSource={info}\n    onRemoveData={this.onRemoveDat\n    flag={flag}\n    onRef={(ref) => { this.cus = ref }} // 获取整个Child元素\n/>\n\n\n handleCancelEdit = () => {\n        const cus = this.cus;\n        const fam = this.fam;\n        const con = this.con;\n        const cusForm = cus.props.form;\n        const famForm = fam.props.form;\n        const conForm = con.props.form;\n        cusForm.resetFields();\n        famForm.resetFields();\n        conForm.resetFields();\n        this.setState({\n            flag: true\n        });\n    }\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("子组件")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    componentDidMount() {\n        const { onRef } = this.props;\n        onRef && onRef(this);\n    }\n")])])]),a("h2",{attrs:{id:"_13-vue组件之间的数据传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue组件之间的数据传递"}},[e._v("#")]),e._v(" 13. Vue组件之间的数据传递")]),e._v(" "),a("ol",[a("li",[e._v("若子组件给父组件传值，可使用 $emit 方法")]),e._v(" "),a("li",[e._v("祖孙组件之间可以使用 provide 和 inject 方式跨层级传值，允许一个祖先组件向其所有子孙后代。")]),e._v(" "),a("li",[e._v("若子组件使用 $emit('say') 派发事件，父组件可使用 @say 监听")]),e._v(" "),a("li",[e._v("若父组件给子组件传值，子组件可通过 props 接受数据")])]),e._v(" "),a("h2",{attrs:{id:"_14-props校验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-props校验"}},[e._v("#")]),e._v(" 14. Props校验")]),e._v(" "),a("ol",[a("li",[e._v("js为弱类语言，可使用type为Props进行"),a("strong",[e._v("类型")]),e._v("或者"),a("strong",[e._v("默认值")]),e._v("的指定。")]),e._v(" "),a("li",[e._v("设置：type 可设置为 "),a("code",[e._v("String Number Boolean Array Object Date Function Symbol")])]),e._v(" "),a("li",[e._v("设置为自定义函数")]),e._v(" "),a("li",[e._v("设置为自定义的构造函数")])]),e._v(" "),a("h2",{attrs:{id:"_15-key值的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-key值的使用"}},[e._v("#")]),e._v(" 15. key值的使用")]),e._v(" "),a("ol",[a("li",[e._v('v-for，如果不使用key，value会默认使用一种"就地复用"的策略进行更新。在一些情况下会导致渲染的不正确。')]),e._v(" "),a("li",[e._v("v-router，会遇到 /path/:id，这样只改变id号的场景，但是渲染的是不同的组件。"),a("strong",[e._v("由于router-view是复用的，单纯的改变id号是不会刷新router-view")]),e._v("。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("解决方法\n为每个router-view添加不同的key，让vue每次切换路由的参数的时候，认为是不同的组件从而得到更新\n\n<router-view :key = 'key'></router-view>\n\n实际上对所有的DOM，Vue都可能会采取复用策略，遇到渲染顺序不准确的，可以向key方向考虑。\n")])])]),a("h2",{attrs:{id:"_16-hookevent的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-hookevent的使用"}},[e._v("#")]),e._v(" 16. hookEvent的使用")]),e._v(" "),a("p",[a("code",[e._v("https://juejin.im/post/6872128694639394830#heading-7")])]),e._v(" "),a("ol",[a("li",[e._v("hookEvent模板式的注入声明周期函数钩子。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("加载list需要很长时间，中间加载loading\n<List @hook:updated= 'handleTableUpdated'></List>\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("组件销毁的新方式")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("旧\nmounted(){\n  this.thirdPartyPlugin = thirdPartyPlugin()\n},\n\nbeforeDestroy(){\n  this.thirdPartyPlugin.destroy()\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("新\nmounted(){\n  const this.thirdPartyPlugin = thirdPartyPlugin()\n  this.$on('hook:beforeDestory', () => {\n    this.thirdPartyPlugin.destory();\n  })\n}\n\n")])])]),a("h2",{attrs:{id:"_18-v-loader中的scoped"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-v-loader中的scoped"}},[e._v("#")]),e._v(" 18. v-loader中的scoped")]),e._v(" "),a("ol",[a("li",[e._v("当"),a("code",[e._v("<style>")]),e._v("标签有scoped时.css只作用于当前元素，通过使用PostCss转换。会添加专属的[data-v-f3f3eg9]")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<style scoped>\n.example{           // .example[data-v-f3f3eg9]{\n  coloe: red;\n}\n</style>\n\n<template>\n  <div calss = "example"> hi </div>             //<div calss = "example"  data-v-f3f3eg9> hi </div>     \n</template>\n')])])]),a("h2",{attrs:{id:"_19-动态指令参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-动态指令参数"}},[e._v("#")]),e._v(" 19. 动态指令参数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<template>\n  <button @[someEvent] = \'handSomeEvent()\'></button>\n</template>\n\n<script>\n  data(){\n    return{\n      someEvent:someCondition ? "Click" : "dblclick"\n    }\n  },\n  methods:{\n    handSomeEvent(){\n\n    }\n  }\n<\/script>\n\n')])])]),a("h2",{attrs:{id:"_20-watch-immediate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-watch-immediate"}},[e._v("#")]),e._v(" 20. watch immediate")]),e._v(" "),a("ol",[a("li",[e._v("组件中watch一个值，进行一些页面初始化或者更新操作，如this.getDetails()")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("watch(){\n  id:{\n    handler(newVuale){\n      this.getDetail(newValue)\n    }\n  }\n}\nwatch 在最初绑定的时候是不会执行的，要等到id改变时才执行监听，这可能会导致第一次渲染出错。\n\n\n想watch中声明了id后立即执行handler方法，可以加上immediate：true\nwatch(){\n  id:{\n    handler(newValue){\n      this.getDetail(newValue)\n    }\n  },\n  // watch中声明了id后，立即执行handler方法。\n  immediate:true\n}\n")])])]),a("h2",{attrs:{id:"_21-v-cloak解决页面闪烁问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-v-cloak解决页面闪烁问题"}},[e._v("#")]),e._v(" 21. v-cloak解决页面闪烁问题")]),e._v(" "),a("ol",[a("li",[e._v("页面数据模板中的数据都是异步获取的，在网络不好的情况下，会出现闪烁的效果。影像用户体验。")]),e._v(" "),a("li",[e._v("v-cloak保持在元素上直到关联实例结束编译。利用特性，结合css规则"),a("code",[e._v("[v-cloak]{dispaly: none}")]),e._v("，一起使用就可以隐藏掉未编译好的Mustache标签，直到实例完毕。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// template中\n<div class="#app">\n  <p>{{value.name}}</p>\n</div>\n\n// css中\n[v-cloak]{\n  display: none\n}\n')])])]),a("blockquote",[a("p",[e._v("需要注意，虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个 loading 或者骨架屏的效果，提升用户体验。")])]),e._v(" "),a("h2",{attrs:{id:"_22-v-once-v-pre"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-v-once-v-pre"}},[e._v("#")]),e._v(" 22. v-once v-pre")]),e._v(" "),a("ol",[a("li",[e._v("v-once 渲染元素或者组件一次。重新渲染的话，元素/组件及其所有子节点会被视为"),a("strong",[e._v("静态内容")]),e._v("跳过。")]),e._v(" "),a("li",[e._v("v-pre  决定要不要跳过这个元素和子元素的编译。")])]),e._v(" "),a("h2",{attrs:{id:"_23-表单输入控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-表单输入控制"}},[e._v("#")]),e._v(" 23. 表单输入控制")]),e._v(" "),a("ol",[a("li",[e._v("表单修饰符")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('.number 自动将用户输入转化为数值类型\n<input v-model.number = "age"  type = "number" />\n\n.trim 自动过滤用户输入的首尾空白字符\n<input v-model.trim = "msg"/>\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("change事件")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<imput v-model="value2" type="text" @change="inputChange(value2)" />\n\nmetho: {\n  inputChange(val){\n    if(!val) return \'\'\n    val = val.toString()\n    this.value2 = val.charAt(0).toUpperCase()+val.slice(1)\n  }\n}\n')])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("filter过滤器")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<input v-model=\"value1\" type=\"text\" />\n\nvue.filter('capitalize', function(value){\n  if(!value) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nwatch: {\n  value1(val){\n    this.value1 = this.$option.filters.capitalize(val)\n  }\n}\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("自定义指令\n声明一个全局指令")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n")])])]),a("h2",{attrs:{id:"_24-事件：特殊变量-event"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-事件：特殊变量-event"}},[e._v("#")]),e._v(" 24. 事件：特殊变量$event")]),e._v(" "),a("ol",[a("li",[e._v("原生事件：绑定事件后，传入除了原生对象之外的参数。监听原生DOM事件，方法以原生事件对象为唯一参数（默认值）。想在内联处理器中访问原始的dom事件（同时想传其他参数），可以使用$event传入。\n"),a("code",[e._v("https://juejin.im/post/6872128694639394830#heading-17")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input v-model = "value1" @change = "inputChange(\'hellow\', $event)" />\n\nmethods: {\n  inputChange(msg, e){\n    console.log(msg, e)\n  }\n}\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("自定义事件：$event是从子组件中捕获的值。监听el-input的传递过来值的同时，传递其他的参数。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<el-input\n  v-model = "value2"\n  @change = "change($event, \'hellow\')"\n  placeholder = "Input sonething here"\n/>\n\nmethods: {\n  change(e, val){\n    console.log("evevt is " + e); // el-input 输入的值\n    console.log(val) // hellow\n  }\n}\n')])])]),a("h2",{attrs:{id:"_25-vue的双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue的双向绑定"}},[e._v("#")]),e._v(" 25. vue的双向绑定")]),e._v(" "),a("blockquote",[a("p",[e._v("https://segmentfault.com/a/1190000019722065  示例\n"),a("img",{attrs:{src:n(392),alt:"vue-Observer"}})])]),e._v(" "),a("ul",[a("li",[e._v("利用 Object.defineProperty() 对数据进行劫持，设置一个监听器 Observer，用来监听数据对象的属性，如果属性上发生变化了，交由 Dep 通知订阅者 Watcher 去更新数据，最后指令解析器 Compile 解析对应的指令，进而会执行对应的更新函数，从而更新视图，实现了双向绑定。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Observer (数据劫持)\nDep (发布订阅)\nWatcher (数据监听)\nCompile (模版编译)\n")])])]),a("h2",{attrs:{id:"_26-单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-单元测试"}},[e._v("#")]),e._v(" 26. 单元测试")]),e._v(" "),a("p",[a("code",[e._v("https://www.jianshu.com/p/ba76cfcac72c")])]),e._v(" "),a("h2",{attrs:{id:"_27-vue实现组件递归（嵌套自身）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-vue实现组件递归（嵌套自身）"}},[e._v("#")]),e._v(" 27. vue实现组件递归（嵌套自身）")]),e._v(" "),a("p",[a("code",[e._v("https://blog.csdn.net/weixin_43245095/article/details/109504127")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 递归组件 demo.vue   自己调用自己\n<template>\n  <div>\n    <div v-for="(item, index) in treeData" :key="index">\n      <p>{{ item.title }}</p>\n      <div class="children" v-if="item.children">\n     \x3c!-- 嵌套自身 --\x3e\n        <Demo :treeData="item.children"></Demo>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: "Demo",\n  props: ["treeData"],\n  data() {\n    return {};\n  },\n  created() {},\n};\n<\/script>\n<style  scoped>\n.children {\n  padding-left: 10px;\n}\n</style>\n\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('父组件调用demo.vue\n<demo :treeData="treeData" ></demo>\n//   模拟递归\n      treeData: [\n        {\n          title: "递归层1",\n          children: [\n            {\n              title: "递归层1-1",\n              children: [\n                {\n                  title: "递归层1-1-1",\n                },\n                {\n                  title: "递归层1-2-1",\n                  children: [\n                    {\n                      title: "递归层1-2-1-1",\n                    },\n                    {\n                      title: "递归层1-2-1-2",\n                    },\n                  ],\n                },\n              ],\n            },\n            {\n              title: "递归层1-2",\n            },\n          ],\n        },\n      ],\n\n\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);