(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{425:function(n,t,e){"use strict";e.r(t);var a=e(43),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"_1-单例模式-一个类只能构造出唯一实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-单例模式-一个类只能构造出唯一实例"}},[n._v("#")]),n._v(" 1. 单例模式: 一个类只能构造出唯一实例")]),n._v(" "),e("h3",{attrs:{id:"_1-1-创建单例模式两个条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-创建单例模式两个条件"}},[n._v("#")]),n._v(" 1.1 创建单例模式两个条件")]),n._v(" "),e("ul",[e("li",[n._v("确保只有一个实例")]),n._v(" "),e("li",[n._v("可全局访问")])]),n._v(" "),e("h3",{attrs:{id:"_1-2-适用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-适用"}},[n._v("#")]),n._v(" 1.2 适用")]),n._v(" "),e("ul",[e("li",[n._v("适用于弹框的实现，全局缓存")])]),n._v(" "),e("h3",{attrs:{id:"_1-3-实现单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-实现单例模式"}},[n._v("#")]),n._v(" 1.3 实现单例模式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const singleton = function(name){\n    this.name = name\n    this.instance = null\n}\n\nsingleton.prototype.getName = function(){\n    console.log(this.name)\n}\n\nsingleton.getInstance = function(name){\n    if(this.instance){\n        this.instance = new singleton(name)    \n    }\n    return this.singleton\n}\n\n// test \nconst a = singleton.getInstance('a'); // 通过getInstance获取实例\nconst b = singleton.getInstance('b');\nconsole.log(a === b)\n")])])]),e("h3",{attrs:{id:"_1-4-javascript中的单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-javascript中的单例模式"}},[n._v("#")]),n._v(" 1.4 JavaScript中的单例模式")]),n._v(" "),e("ul",[e("li",[n._v("js是无类型语言，js"),e("strong",[n._v("全局对象符")]),n._v("合单例模式的两个条件。可以当成单例模式。"),e("code",[n._v("var obj = {}")])])]),n._v(" "),e("h3",{attrs:{id:"弹窗层实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#弹窗层实践"}},[n._v("#")]),n._v(" 弹窗层实践")]),n._v(" "),e("ul",[e("li",[n._v("建好弹窗，隐藏，浪费不必要的DOM开销")]),n._v(" "),e("li",[n._v("需要时创建，结合单例模式只有一个实例，从而节省DOM开销。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const createLoginLayer = function() {\n  const div = document.createElement('div')\n  div.innerHTML = '登入浮框'\n  div.style.display = 'none'\n  document.body.appendChild(div)\n  return div\n}\n\n使单例模式和创建弹框代码解耦\nconst getSingle = function(fn) {\n  const result\n  return function() {\n    return result || result = fn.apply(this, arguments)\n  }\n}\n\n\nconst createSingleLoginLayer = getSingle(createLoginLayer)\ndocument.getElementById('loginBtn').onclick = function() {\n  createSingleLoginLayer()\n}\n")])])]),e("h2",{attrs:{id:"_2-发布-订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-发布-订阅模式"}},[n._v("#")]),n._v(" 2. 发布-订阅模式:")]),n._v(" "),e("p",[e("code",[n._v("https://segmentfault.com/a/1190000019722065")]),e("br"),n._v(" "),e("strong",[n._v("基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。")])]),n._v(" "),e("p",[e("strong",[n._v("[！！！！！！！！！！！]发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。")])]),n._v(" "),e("ul",[e("li",[n._v("创建订阅者需要消耗一定的内存和时间。虽然可以弱化对象之间的联系，过度使用不利于代码的理解。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 订阅\ndocument.body.addEventListener('click', function() {\n  console.log('click1');\n}, false);\n\ndocument.body.addEventListener('click', function() {\n  console.log('click2');\n}, false);\n\n// 发布\ndocument.body.click(); // click1  click2\n")])])]),e("h2",{attrs:{id:"_3-观察者模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-观察者模式"}},[n._v("#")]),n._v(" 3.观察者模式:")]),n._v(" "),e("p",[e("strong",[n._v("定义了对象间一种一对多的依赖关系，当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知。")])]),n._v(" "),e("ul",[e("li",[n._v("observer(观察者)监听Model(js对象)的变化， 最核心的部分就是用到Object.defineProperty()中的"),e("strong",[n._v("get")]),n._v("和"),e("strong",[n._v("set")]),n._v("方法，获取对象是自动调用get，该动时自动调用set，实现最数据的劫持。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let data = {\n    number: 0\n}\n\nobserve(data)\n\ndata.number = 1\n\nfunction observer(data) {\n    if(!data || typeof(data) !== 'object'){\n        return\n    }\n    const self = this\n\n    Object.keys(data).forEach(key => {\n        self.defineReactive(data, key, data[key])\n    })\n\n    function defineReactive(data, key, value){\n        observer(value)\n            Object.defineProperty(data, key, {\n                get: function(){\n                    return value;\n                }\n                set: function(newValue){\n                    if(value !== newVlaue){\n                        value = newValue\n                    }\n                }\n            })\n    }\n}\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);