(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{450:function(t,e,a){"use strict";a.r(e);var r=a(43),o=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前端路由规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端路由规则"}},[t._v("#")]),t._v(" 前端路由规则")]),t._v(" "),a("p",[a("code",[t._v("https://juejin.im/post/6883729053027844109#heading-5")])]),t._v(" "),a("h3",{attrs:{id:"一-url中的hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-url中的hash"}},[t._v("#")]),t._v(" 一 Url中的hash")]),t._v(" "),a("ol",[a("li",[t._v("Url的hash也就是锚点（#），本质上是改变window.location的href属性。可以直接复制location.hash改变url，但是"),a("strong",[t._v("页面不会刷新。")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const routerViewOne = doucument.querySelector('.router-view')\nwindow.addEventListener('hashChange', () => {\n    switch(window.loctiona.hash){\n        case '#/home'\n            routerViewOne.innerHtml = '首页'\n            break;\n        case '#/about'\n            routerViewOne.innerHtml = '关于'\n            break;\n        default:\n            routerViewOne.innerHtml = ''\n            break;\n    }\n})\n")])])]),a("blockquote",[a("p",[t._v("hash的优势是兼容性更强，老版IE中也可运行。缺陷"),a("code",[t._v("#/")]),t._v("显得不想真是路径名")])]),t._v(" "),a("h3",{attrs:{id:"二-html5中的history"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-html5中的history"}},[t._v("#")]),t._v(" 二 Html5中的history")]),t._v(" "),a("ol",[a("li",[t._v("history接口是Html5新增，有六种模式"),a("strong",[t._v("改变Url而不刷新页面")]),t._v("方法：")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("API")]),t._v(" "),a("th",[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("replaceState")]),t._v(" "),a("td",[t._v("提还原来的路径")])]),t._v(" "),a("tr",[a("td",[t._v("pushState")]),t._v(" "),a("td",[t._v("使用新路径")])]),t._v(" "),a("tr",[a("td",[t._v("popState")]),t._v(" "),a("td",[t._v("路径的回退")])]),t._v(" "),a("tr",[a("td",[t._v("go")]),t._v(" "),a("td",[t._v("向前或向后改变路径")])]),t._v(" "),a("tr",[a("td",[t._v("forword")]),t._v(" "),a("td",[t._v("向前改变路径")])]),t._v(" "),a("tr",[a("td",[t._v("back")]),t._v(" "),a("td",[t._v("向后改变路径")])])])]),t._v(" "),a("h2",{attrs:{id:"react-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" react-Router")]),t._v(" "),a("h3",{attrs:{id:"一-react-router介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-react-router介绍"}},[t._v("#")]),t._v(" 一 react-Router介绍")]),t._v(" "),a("ol",[a("li",[t._v("React-Router版本4开始，路由不在集中在一个包管理。react-router是router的核心部分代码，react-router-dom适用于浏览器。react-router-native是用于原生应用。目前是使用的都是V5。安装react-router-dom会自动帮助我们安装react-router依赖。")])]),t._v(" "),a("h3",{attrs:{id:"二-router的基本使用-react-router主要api提供的一些组件，"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-router的基本使用-react-router主要api提供的一些组件，"}},[t._v("#")]),t._v(" 二 Router的基本使用 react-router主要API提供的一些组件，")]),t._v(" "),a("ol",[a("li",[t._v("BrowserRouter或HashRouter组件")])]),t._v(" "),a("ul",[a("li",[t._v("Router中包含了对路径改变时候的监听，并且会将相应的路径传递给子组件")]),t._v(" "),a("li",[t._v("BrowserRouter使用了history模式")]),t._v(" "),a("li",[t._v("HashRouter使用了hash模式")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("Link和NavLink")])]),t._v(" "),a("ul",[a("li",[t._v("跳转使用Link最后会被渲染成a链接")]),t._v(" "),a("li",[t._v("NavLink是在Link基础之上增加了一些样式属性")]),t._v(" "),a("li",[t._v("to属性: link组件中最重要的属性, 用于设置跳转到的路径")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("Route组件用于路径的匹配")])]),t._v(" "),a("ul",[a("li",[t._v("path(属性)：用户设置匹配到的路径")]),t._v(" "),a("li",[t._v("component(属性)：设置到匹配名的后面，渲染组件。")]),t._v(" "),a("li",[t._v("exact(属性)：精准匹配，只有精准匹配到完全一样的路径，才会渲染对应的组件。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import { BorwserRouter, Link, Route }  from \'react-router-dom\'\nexport default class App extends PureComponent {\n    render(){\n        return (\n            <div>\n                <BrowserRouter>\n                    <Link to="/">主页</Link>\n                    <Link to="/about">关于</Link>\n                    <Link to="profile">我的</Link>     \n\n                    <Route exact path="/" component = {Home} />\n                    <Route exact path="/" component =Profile{abut} />\n                    <Route exact path="/Profile" component = {Profile} />\n                </BrowserRouter>\n            </div>\n        )\n    }\n}\n')])])]),a("h3",{attrs:{id:"三-navlink组件的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-navlink组件的使用"}},[t._v("#")]),t._v(" 三 NavLink组件的使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('需求： 路径选中时使用NavLink组件来替代Link组件\n\nactiveStyle: 活跃时（匹配时）的样式\nactiveClassName: 活跃时添加的class\nexact: 是否精准匹配\n\n<NavLink exact to="/"  activeClassName =  "link-active">主页</NavKlink>\n\n<NavLink to="/about" activeStyle={{ color: \'red\', fontsize: \'35px\'}}>关于</NavLink>\n\n')])])]),a("h3",{attrs:{id:"四-switch组件应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-switch组件应用"}},[t._v("#")]),t._v(" 四 Switch组件应用")]),t._v(" "),a("ol",[a("li",[t._v("使用场景：只要有一个path匹配上了对应的组件，后续就不会在进行匹配了。")]),t._v(" "),a("li",[t._v("路由规则：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Route exact path="/" component={Home} />\n<Route path="/about" component={About} />\n<Route path="/profile" component={Profile} />\n<Route path="/:id" component={User} />\n<Route path component={NotMatch} />\n\n如/about匹配的同时，/:userid也会被匹配到，最后的NoMath组件总是被匹配到。    \n')])])]),a("ul",[a("li",[t._v("原因： react-router中只要是路径被匹配到的Route对应的组件都会渲染。")]),t._v(" "),a("li",[t._v("使用Switch包裹，只匹配第一个，后面不再匹配。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/about" component={About} />\n    <Route path="/profile" component={Profile} />\n    <Route path="/:id" component={User} />\n    <Route path component={NotMatch} />\n</Switch>\n')])])]),a("h3",{attrs:{id:"五-redirect重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五-redirect重定向"}},[t._v("#")]),t._v(" 五 Redirect重定向")]),t._v(" "),a("p",[a("code",[t._v("<Redirect to='/login' />")])]),t._v(" "),a("h2",{attrs:{id:"react-router补充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router补充"}},[t._v("#")]),t._v(" react-router补充")]),t._v(" "),a("ol",[a("li",[t._v("路由嵌套")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/home \n/home/news\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("手动路由跳转withRouter")])]),t._v(" "),a("blockquote",[a("p",[t._v("目前实现跳转主要通过Link，NavLink跳转，通过js代码跳转。")])]),t._v(" "),a("ul",[a("li",[t._v("获取history对象"),a("br"),t._v(" "),a("code",[t._v("方式一： 如果该组件通过路由跳转，可以从props属性中获取history,location,match")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("方式二： APP组件中获取到history对象，需要使用whithRouter**高阶组件**  \nAPP组件必须包裹在BrowserRouter或者HashRouter内\nAPP组件必须使用WithRouter高组件包裹\n\n// 1.不使用Link组件或者NavLink组件实现跳转\njoinTo() {\n    // 1. 使用的history是通过Route组件传递。\n    // 2. 通过Route传递的history对象来实现路径跳转\n    this.props.history.push('/about/join')\n}\n\n// app.js\njumpToProduct(){\n    this.props.history.push('/product')\n}\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("参数传递： 动态路由传递， search传递参数， Link中to传入对象。")])]),t._v(" "),a("ul",[a("li",[t._v("动态路由传递")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("将path在Route匹配时写成/detail/:id，那么/detail/abc、/detail/123都可以匹配到该Route，并且进行显示\n\n// APP.js\n<NavLink to={`/detail/${id}`}>详情</NavLink>\n\n<Route path='/detail/:id' component={detail} />\n\n// detail.js\n获取动态路由传递的id参数\n<h2>Detail: {match.params.id}</h2>\n")])])]),a("ul",[a("li",[t._v("search传递参数")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("在Link或NavLink组件通过to属性传递query string\n\n<NavLink to={`/detail2?name=asd&age=18`}>详情2（通过search传参）</NavLink>\n// search获取传递的query\n<h2>Detail2: {this.props.location}</h2>\n")])])]),a("ul",[a("li",[t._v("Link中的to属性直接传递一个对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// app.js\n<NavLink \n    to={{\n        pathname: '/detail',\n        search: '?name=abc',\n        state: info\n    }}\n>进入详情</NavLink>\n\n// detail.js\nconsole.log(this.props.location)\n")])])]),a("h2",{attrs:{id:"react-router-config"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router-config"}},[t._v("#")]),t._v(" react-router-config")]),t._v(" "),a("h3",{attrs:{id:"一-react-router-config基本配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-react-router-config基本配置"}},[t._v("#")]),t._v(" 一 react-router-config基本配置")]),t._v(" "),a("blockquote",[a("p",[t._v("目前我们所有的路由定义都是直接使用Route组件，并且添加属性来完成的 但是这样的方式会让路由变得非常混乱")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("- 将所有的路由配置放到一个地方进行集中管理，使用: react-router-config来完成\n- 安装react-router-config  yarn add react-router-config  配置路由映射关系数组\n\nconst routes = [\n  { path: '/', component: Home, exact: true },\n  { path: '/profile', component: Profile },\n  { path: '/detail/:id', component: Detail },\n]\n// app.js\nimport { renderRoutes } from 'react-router-config'\nimport routes from './router'\n    render() {\n        // ...\n        { renderRoutes(routes) }\n    }\n// about.js\n")])])]),a("h3",{attrs:{id:"二-嵌套子路由配置映射关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-嵌套子路由配置映射关系"}},[t._v("#")]),t._v(" 二 嵌套子路由配置映射关系")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("在路由嵌套中配置路由映射关系\nconst routes = [\n  {\n    path: '/about',\n    component: About,\n    route: [\n      { \n          path: '/about', \n          component: AboutHistory, \n          exact: true \n      },\n      {\n        path: '/about/join',\n        component: AboutJoin,\n      },\n    ]\n  }\n]\n// about.js ( 在被Route渲染的组件中: 使用props取出route )\n  render() {\n     { renderRoutes(this.props.route.route) }\n  }\n\n")])])]),a("h2",{attrs:{id:"browserrouter-hashrouter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#browserrouter-hashrouter"}},[t._v("#")]),t._v(" BrowserRouter HashRouter")]),t._v(" "),a("p",[t._v("BrowserRouter：\nHashRouter")]),t._v(" "),a("p",[t._v("底层原理：底层原理使用H5的history API，不兼容IE9及以下版本"),a("br"),t._v("\n底层原理：使用URL的哈希值，兼容性更好")]),t._v(" "),a("p",[t._v("path形式：路径中没有#，localhost:3000/demo/test"),a("br"),t._v("\npath形式：路径包含#，localhost:3000/#/demo/test")]),t._v(" "),a("p",[t._v("刷新后对路由state参数的影响 ：没有任何影响，因为state保存在history对象中"),a("br"),t._v("\n刷新后对路由state参数的影响 ：刷新后会导致路由state参数的丢失！")]),t._v(" "),a("p",[t._v("备注：HashRouter可以用于解决一些路径错误相关的问题。")])])}),[],!1,null,null,null);e.default=o.exports}}]);