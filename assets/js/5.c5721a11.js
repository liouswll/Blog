(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{348:function(t,n,r){t.exports=r.p+"assets/img/erchashu.ee39813b.png"},349:function(t,n,r){t.exports=r.p+"assets/img/erchashuu.e5063124.png"},350:function(t,n,r){t.exports=r.p+"assets/img/erchashuB.640a145a.png"},351:function(t,n,r){t.exports=r.p+"assets/img/er.a2a14e24.png"},352:function(t,n,r){t.exports=r.p+"assets/img/erb.2c20bde0.png"},353:function(t,n,r){t.exports=r.p+"assets/img/ers.6ee17141.png"},440:function(t,n,r){"use strict";r.r(n);var e=r(43),a=Object(e.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"二叉树和二叉查找树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树和二叉查找树"}},[t._v("#")]),t._v(" 二叉树和二叉查找树")]),t._v(" "),e("h2",{attrs:{id:"二叉树和二叉查找树-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树和二叉查找树-2"}},[t._v("#")]),t._v(" 二叉树和二叉查找树")]),t._v(" "),e("h2",{attrs:{id:"树的基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#树的基本概念"}},[t._v("#")]),t._v(" 树的基本概念")]),t._v(" "),e("ul",[e("li",[t._v("一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。\n"),e("img",{attrs:{src:r(348),alt:"erchashu"}})])]),t._v(" "),e("h2",{attrs:{id:"二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),e("ul",[e("li",[t._v("一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。\n"),e("img",{attrs:{src:r(349),alt:"erchashuu"}})])]),t._v(" "),e("h2",{attrs:{id:"二叉查找树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉查找树"}},[t._v("#")]),t._v(" 二叉查找树")]),t._v(" "),e("ul",[e("li",[t._v("二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。")])]),t._v(" "),e("h2",{attrs:{id:"定义节点（实现二叉查找树）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义节点（实现二叉查找树）"}},[t._v("#")]),t._v(" 定义节点（实现二叉查找树）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Node(data,left,right) {\n    this.left = left;\n    this.right = right;\n    this.data = data;\n    this.show = () => {return this.data}\n}\n\n节点：二叉树的最小结构单元\n")])])]),e("h2",{attrs:{id:"二叉树（实现二叉查找树）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树（实现二叉查找树）"}},[t._v("#")]),t._v(" 二叉树（实现二叉查找树）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function BST() {\n    this.root = null //初始化,root为null\n}\n")])])]),e("ul",[e("li",[t._v("初始化时为根节点")]),t._v(" "),e("li",[t._v("如果BST.root === null ，那么就将节点作为根节点")]),t._v(" "),e("li",[t._v("如果BST.root !==null ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("最左变的叶子节点是最小的数，最右的叶子节点是最大的数\nfunction insert(data) {\n    var node = new Node(data,null,null);\n    if(this.root === null) {\n        this.root = node\n    } else {\n        var current = this.root;\n        var parent;\n        while(true) {\n            parent = current;\n            if(data < current.data) {\n                current = current.left; //到左子树\n                if(current === null) {  //如果左子树为空，说明可以将node插入在这里\n                    parent.left = node;\n                    break;  //跳出while循环\n                }\n            } else {\n                current = current.right;\n                if(current === null) {\n                    parent.right = node;\n                    break;\n                }\n            }\n        }\n    }\n}\n使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。\n\n\n接下来，将此方法写入BST即可\nfunction BST() {\n    this.root = null;\n    this.insert = insert;\n}\n\n\nvar bst = new BST()；\nbst.insert(10);\nbst.insert(8);\nbst.insert(2);\nbst.insert(7);\nbst.insert(5);\n")])])]),e("h2",{attrs:{id:"二叉树遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树遍历"}},[t._v("#")]),t._v(" 二叉树遍历")]),t._v(" "),e("p",[e("img",{attrs:{src:r(350),alt:"erchashuB"}})]),t._v(" "),e("ol",[e("li",[t._v("前序遍历: 56 22 10 30 81 77 92  （根左右）")]),t._v(" "),e("li",[t._v("中序遍历: 10 22 30 56 77 81 92   （左根右）")]),t._v(" "),e("li",[t._v("后序遍历: 10 30 22 77 92 81 56   （最后一层-左右根）")])]),t._v(" "),e("h2",{attrs:{id:"中序遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中序遍历"}},[t._v("#")]),t._v(" 中序遍历")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function inOrder(node) {\n    if(node !== null) {\n        //如果不是null，就一直查找左变，因此递归\n        inOrder(node.left);\n        //递归结束，打印当前值\n        console.log(node.show());\n        //上一次递归已经把左边搞完了，右边\n        inOrder(node.right);\n    }\n}\n\n//在刚才已有bst的基础上执行命令\ninOrder(bst.root);\n\n// 打印结果2 5 7 8 10\n")])])]),e("h2",{attrs:{id:"前序遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前序遍历"}},[t._v("#")]),t._v(" 前序遍历")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function preOrder(node) {\n    if(node !== null) {\n        //根左右\n        console.log(node.show());\n        preOrder(node.left);\n        preOrder(node.right);\n    }\n}\n\n")])])]),e("h2",{attrs:{id:"后续遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后续遍历"}},[t._v("#")]),t._v(" 后续遍历")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function postOrder(node) {\n    if(node !== null) {\n        //左右根\n        postOrder(node.left);\n        postOrder(node.right);\n        console.log(node.show())\n    }\n}\n")])])]),e("h2",{attrs:{id:"二叉树查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树查找"}},[t._v("#")]),t._v(" 二叉树查找")]),t._v(" "),e("ul",[e("li",[t._v("最小值： 最左子树的叶子节点")]),t._v(" "),e("li",[t._v("最大值： 最右子树的叶子节点")]),t._v(" "),e("li",[t._v("特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//最小值\nfunction getMin(bst) {\n    var current = bst.root;\n    while(current.left !== null) {\n        current = current.left;\n    }\n    return current.data;\n}\n\n//最大值\nfunction getMax(bst) {\n    var current = bst.root;\n    while(current.right !== null) {\n        current = current.right;\n    }\n    return current.data;\n}\n\n// 特定值\nfunction find(target,bst) {\n    var current = bst.root;\n    while(current !== null) {\n        if(target === current.data) {\n            return true;\n        }\n        else if(target > current.data) {\n            current = current.right;\n        } else if(target < current.data) {\n            current = current.left;\n        }\n    }\n    return -1;\n}\n一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。\n")])])]),e("h2",{attrs:{id:"满二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#满二叉树"}},[t._v("#")]),t._v(" 满二叉树")]),t._v(" "),e("ol",[e("li",[t._v("高度为h，由2^h-1个节点构成的二叉树称为满二叉树。"),e("br"),t._v(" "),e("img",{attrs:{src:r(351),alt:"er"}})])]),t._v(" "),e("h2",{attrs:{id:"完全二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[t._v("#")]),t._v(" 完全二叉树")]),t._v(" "),e("ol",[e("li",[t._v("全二叉树是由满二叉树而引出来的，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n"),e("img",{attrs:{src:r(352),alt:"erb"}})])]),t._v(" "),e("h2",{attrs:{id:"二叉树的深度优先遍历-dfs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的深度优先遍历-dfs"}},[t._v("#")]),t._v(" 二叉树的深度优先遍历(DFS)")]),t._v(" "),e("ol",[e("li",[t._v("根节点出发，纵向遍历，直到找到叶子结点为止。回溯上一个节点，进行右子树节点遍历。直到遍历完所有可达节点为止。DFS:ABDGCEFH"),e("br"),t._v(" "),e("img",{attrs:{src:r(353),alt:"ers"}})])]),t._v(" "),e("h2",{attrs:{id:"二叉树的广度优先遍历-bfs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的广度优先遍历-bfs"}},[t._v("#")]),t._v(" 二叉树的广度优先遍历(BFS)")]),t._v(" "),e("ol",[e("li",[t._v("根节点出发，横向遍历。BFS：ABCDGEFH")])])])}),[],!1,null,null,null);n.default=a.exports}}]);